// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "update_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* Rotation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Rotation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Wheel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Wheel_reflection_ = NULL;
const ::google::protobuf::Descriptor* Button_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Button_reflection_ = NULL;
const ::google::protobuf::Descriptor* Mouse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Mouse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataDescription_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataDescription_reflection_ = NULL;
const ::google::protobuf::Descriptor* LabeledMarker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LabeledMarker_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrackedBody_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrackedBody_reflection_ = NULL;
const ::google::protobuf::Descriptor* Mocap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Mocap_reflection_ = NULL;
const ::google::protobuf::Descriptor* Update_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Update_reflection_ = NULL;
const ::google::protobuf::Descriptor* Updates_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Updates_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_update_5fprotocol_2eproto() {
  protobuf_AddDesc_update_5fprotocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "update_protocol.proto");
  GOOGLE_CHECK(file != NULL);
  Position_descriptor_ = file->message_type(0);
  static const int Position_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, z_),
  };
  Position_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Position_descriptor_,
      Position::default_instance_,
      Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _has_bits_[0]),
      -1,
      -1,
      sizeof(Position),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _internal_metadata_),
      -1);
  Rotation_descriptor_ = file->message_type(1);
  static const int Rotation_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, w_),
  };
  Rotation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Rotation_descriptor_,
      Rotation::default_instance_,
      Rotation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, _has_bits_[0]),
      -1,
      -1,
      sizeof(Rotation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rotation, _internal_metadata_),
      -1);
  Wheel_descriptor_ = file->message_type(2);
  static const int Wheel_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wheel, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wheel, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wheel, tick_),
  };
  Wheel_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Wheel_descriptor_,
      Wheel::default_instance_,
      Wheel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wheel, _has_bits_[0]),
      -1,
      -1,
      sizeof(Wheel),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wheel, _internal_metadata_),
      -1);
  Button_descriptor_ = file->message_type(3);
  static const int Button_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Button, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Button, state_),
  };
  Button_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Button_descriptor_,
      Button::default_instance_,
      Button_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Button, _has_bits_[0]),
      -1,
      -1,
      sizeof(Button),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Button, _internal_metadata_),
      -1);
  Mouse_descriptor_ = file->message_type(4);
  static const int Mouse_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, connected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, buttons_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, wheels_),
  };
  Mouse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Mouse_descriptor_,
      Mouse::default_instance_,
      Mouse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, _has_bits_[0]),
      -1,
      -1,
      sizeof(Mouse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mouse, _internal_metadata_),
      -1);
  DataDescription_descriptor_ = file->message_type(5);
  static const int DataDescription_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, dd_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, item_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, parentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, parentoffsetx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, parentoffsety_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, parentoffsetz_),
  };
  DataDescription_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DataDescription_descriptor_,
      DataDescription::default_instance_,
      DataDescription_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, _has_bits_[0]),
      -1,
      -1,
      sizeof(DataDescription),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescription, _internal_metadata_),
      -1);
  LabeledMarker_descriptor_ = file->message_type(6);
  static const int LabeledMarker_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabeledMarker, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabeledMarker, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabeledMarker, position_),
  };
  LabeledMarker_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LabeledMarker_descriptor_,
      LabeledMarker::default_instance_,
      LabeledMarker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabeledMarker, _has_bits_[0]),
      -1,
      -1,
      sizeof(LabeledMarker),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabeledMarker, _internal_metadata_),
      -1);
  TrackedBody_descriptor_ = file->message_type(7);
  static const int TrackedBody_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, trackingvalid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, rotation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, meanerror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, markers_),
  };
  TrackedBody_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrackedBody_descriptor_,
      TrackedBody::default_instance_,
      TrackedBody_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrackedBody),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBody, _internal_metadata_),
      -1);
  Mocap_descriptor_ = file->message_type(8);
  static const int Mocap_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, duringrecording_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, trackedmodelschanged_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, timecode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, tracked_bodies_),
  };
  Mocap_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Mocap_descriptor_,
      Mocap::default_instance_,
      Mocap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, _has_bits_[0]),
      -1,
      -1,
      sizeof(Mocap),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mocap, _internal_metadata_),
      -1);
  Update_descriptor_ = file->message_type(9);
  static const int Update_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, mod_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, mocap_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, mice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, strokes_),
  };
  Update_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Update_descriptor_,
      Update::default_instance_,
      Update_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _has_bits_[0]),
      -1,
      -1,
      sizeof(Update),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _internal_metadata_),
      -1);
  Updates_descriptor_ = file->message_type(10);
  static const int Updates_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Updates, mod_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Updates, updates_),
  };
  Updates_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Updates_descriptor_,
      Updates::default_instance_,
      Updates_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Updates, _has_bits_[0]),
      -1,
      -1,
      sizeof(Updates),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Updates, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_update_5fprotocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Position_descriptor_, &Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Rotation_descriptor_, &Rotation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Wheel_descriptor_, &Wheel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Button_descriptor_, &Button::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Mouse_descriptor_, &Mouse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DataDescription_descriptor_, &DataDescription::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LabeledMarker_descriptor_, &LabeledMarker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrackedBody_descriptor_, &TrackedBody::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Mocap_descriptor_, &Mocap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Update_descriptor_, &Update::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Updates_descriptor_, &Updates::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_update_5fprotocol_2eproto() {
  delete Position::default_instance_;
  delete Position_reflection_;
  delete Rotation::default_instance_;
  delete Rotation_reflection_;
  delete Wheel::default_instance_;
  delete Wheel_reflection_;
  delete Button::default_instance_;
  delete Button_reflection_;
  delete Mouse::default_instance_;
  delete Mouse_reflection_;
  delete DataDescription::default_instance_;
  delete DataDescription_reflection_;
  delete LabeledMarker::default_instance_;
  delete LabeledMarker_reflection_;
  delete TrackedBody::default_instance_;
  delete TrackedBody_reflection_;
  delete Mocap::default_instance_;
  delete Mocap_reflection_;
  delete Update::default_instance_;
  delete Update_reflection_;
  delete Updates::default_instance_;
  delete Updates_reflection_;
}

void protobuf_AddDesc_update_5fprotocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025update_protocol.proto\"+\n\010Position\022\t\n\001x"
    "\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"6\n\010Rotation"
    "\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\022\t\n\001w\030\004"
    " \002(\001\"4\n\005Wheel\022\n\n\002id\030\001 \002(\t\022\021\n\tdirection\030\002"
    " \002(\t\022\014\n\004tick\030\003 \002(\005\"#\n\006Button\022\n\n\002id\030\001 \002(\t"
    "\022\r\n\005state\030\002 \002(\t\"f\n\005Mouse\022\n\n\002id\030\001 \002(\t\022\021\n\t"
    "connected\030\002 \002(\010\022\014\n\004name\030\003 \002(\t\022\030\n\007buttons"
    "\030\004 \003(\0132\007.Button\022\026\n\006wheels\030\005 \003(\0132\006.Wheel\""
    "\226\001\n\017DataDescription\022\014\n\004name\030\001 \002(\t\022\r\n\005dd_"
    "id\030\002 \002(\005\022\017\n\007item_id\030\003 \002(\005\022\020\n\010parentId\030\004 "
    "\002(\021\022\025\n\rparentOffsetX\030\005 \002(\021\022\025\n\rparentOffs"
    "etY\030\006 \002(\021\022\025\n\rparentOffsetZ\030\007 \002(\021\"F\n\rLabe"
    "ledMarker\022\n\n\002id\030\001 \002(\005\022\014\n\004size\030\002 \002(\001\022\033\n\010p"
    "osition\030\003 \002(\0132\t.Position\"\255\001\n\013TrackedBody"
    "\022\n\n\002id\030\001 \002(\005\022\r\n\005label\030\002 \002(\t\022\025\n\rtrackingV"
    "alid\030\003 \002(\010\022\033\n\010position\030\004 \002(\0132\t.Position\022"
    "\033\n\010rotation\030\005 \002(\0132\t.Rotation\022\021\n\tmeanErro"
    "r\030\006 \001(\002\022\037\n\007markers\030\007 \003(\0132\016.LabeledMarker"
    "\"v\n\005Mocap\022\027\n\017duringRecording\030\001 \002(\010\022\034\n\024tr"
    "ackedModelsChanged\030\002 \002(\010\022\020\n\010timecode\030\003 \001"
    "(\t\022$\n\016tracked_bodies\030\004 \003(\0132\014.TrackedBody"
    "\"\200\001\n\006Update\022\n\n\002id\030\001 \002(\t\022\023\n\013mod_version\030\002"
    " \002(\005\022\014\n\004time\030\003 \002(\005\022\025\n\005mocap\030\004 \001(\0132\006.Moca"
    "p\022\024\n\004mice\030\005 \003(\0132\006.Mouse\022\032\n\007strokes\030\006 \003(\013"
    "2\t.Position\"8\n\007Updates\022\023\n\013mod_version\030\001 "
    "\002(\005\022\030\n\007updates\030\002 \003(\0132\007.UpdateB)\n\027com.mrl"
    ".update_protocolB\016UpdateProtocol", 1072);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "update_protocol.proto", &protobuf_RegisterTypes);
  Position::default_instance_ = new Position();
  Rotation::default_instance_ = new Rotation();
  Wheel::default_instance_ = new Wheel();
  Button::default_instance_ = new Button();
  Mouse::default_instance_ = new Mouse();
  DataDescription::default_instance_ = new DataDescription();
  LabeledMarker::default_instance_ = new LabeledMarker();
  TrackedBody::default_instance_ = new TrackedBody();
  Mocap::default_instance_ = new Mocap();
  Update::default_instance_ = new Update();
  Updates::default_instance_ = new Updates();
  Position::default_instance_->InitAsDefaultInstance();
  Rotation::default_instance_->InitAsDefaultInstance();
  Wheel::default_instance_->InitAsDefaultInstance();
  Button::default_instance_->InitAsDefaultInstance();
  Mouse::default_instance_->InitAsDefaultInstance();
  DataDescription::default_instance_->InitAsDefaultInstance();
  LabeledMarker::default_instance_->InitAsDefaultInstance();
  TrackedBody::default_instance_->InitAsDefaultInstance();
  Mocap::default_instance_->InitAsDefaultInstance();
  Update::default_instance_->InitAsDefaultInstance();
  Updates::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_update_5fprotocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_update_5fprotocol_2eproto {
  StaticDescriptorInitializer_update_5fprotocol_2eproto() {
    protobuf_AddDesc_update_5fprotocol_2eproto();
  }
} static_descriptor_initializer_update_5fprotocol_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int Position::kXFieldNumber;
const int Position::kYFieldNumber;
const int Position::kZFieldNumber;
#endif  // !_MSC_VER

Position::Position()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Position)
}

void Position::InitAsDefaultInstance() {
}

Position::Position(const Position& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Position)
}

void Position::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:Position)
  SharedDtor();
}

void Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Position_descriptor_;
}

const Position& Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Position* Position::default_instance_ = NULL;

Position* Position::New(::google::protobuf::Arena* arena) const {
  Position* n = new Position;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Position::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Position*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Position)
  return false;
#undef DO_
}

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Position)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Position)
}

::google::protobuf::uint8* Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Position)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Position)
  return target;
}

int Position::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int Position::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Position* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Position>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Position::Swap(Position* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Position::InternalSwap(Position* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Position_descriptor_;
  metadata.reflection = Position_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1;
bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Position::x() const {
  // @@protoc_insertion_point(field_get:Position.x)
  return x_;
}
 void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Position.x)
}

// required double y = 2;
bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Position::y() const {
  // @@protoc_insertion_point(field_get:Position.y)
  return y_;
}
 void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Position.y)
}

// required double z = 3;
bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Position::z() const {
  // @@protoc_insertion_point(field_get:Position.z)
  return z_;
}
 void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Position.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Rotation::kXFieldNumber;
const int Rotation::kYFieldNumber;
const int Rotation::kZFieldNumber;
const int Rotation::kWFieldNumber;
#endif  // !_MSC_VER

Rotation::Rotation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Rotation)
}

void Rotation::InitAsDefaultInstance() {
}

Rotation::Rotation(const Rotation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Rotation)
}

void Rotation::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rotation::~Rotation() {
  // @@protoc_insertion_point(destructor:Rotation)
  SharedDtor();
}

void Rotation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Rotation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Rotation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Rotation_descriptor_;
}

const Rotation& Rotation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Rotation* Rotation::default_instance_ = NULL;

Rotation* Rotation::New(::google::protobuf::Arena* arena) const {
  Rotation* n = new Rotation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Rotation::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Rotation*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Rotation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Rotation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_w;
        break;
      }

      // required double w = 4;
      case 4: {
        if (tag == 33) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Rotation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Rotation)
  return false;
#undef DO_
}

void Rotation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Rotation)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // required double w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Rotation)
}

::google::protobuf::uint8* Rotation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Rotation)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // required double w = 4;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Rotation)
  return target;
}

int Rotation::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
int Rotation::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

    // required double w = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rotation::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Rotation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Rotation>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Rotation::MergeFrom(const Rotation& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Rotation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rotation::CopyFrom(const Rotation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rotation::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Rotation::Swap(Rotation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Rotation::InternalSwap(Rotation* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Rotation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Rotation_descriptor_;
  metadata.reflection = Rotation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Rotation

// required double x = 1;
bool Rotation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Rotation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Rotation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Rotation::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Rotation::x() const {
  // @@protoc_insertion_point(field_get:Rotation.x)
  return x_;
}
 void Rotation::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Rotation.x)
}

// required double y = 2;
bool Rotation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Rotation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Rotation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Rotation::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Rotation::y() const {
  // @@protoc_insertion_point(field_get:Rotation.y)
  return y_;
}
 void Rotation::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Rotation.y)
}

// required double z = 3;
bool Rotation::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Rotation::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Rotation::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Rotation::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Rotation::z() const {
  // @@protoc_insertion_point(field_get:Rotation.z)
  return z_;
}
 void Rotation::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Rotation.z)
}

// required double w = 4;
bool Rotation::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Rotation::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
void Rotation::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void Rotation::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Rotation::w() const {
  // @@protoc_insertion_point(field_get:Rotation.w)
  return w_;
}
 void Rotation::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Rotation.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Wheel::kIdFieldNumber;
const int Wheel::kDirectionFieldNumber;
const int Wheel::kTickFieldNumber;
#endif  // !_MSC_VER

Wheel::Wheel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Wheel)
}

void Wheel::InitAsDefaultInstance() {
}

Wheel::Wheel(const Wheel& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Wheel)
}

void Wheel::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  direction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tick_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Wheel::~Wheel() {
  // @@protoc_insertion_point(destructor:Wheel)
  SharedDtor();
}

void Wheel::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  direction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Wheel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Wheel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Wheel_descriptor_;
}

const Wheel& Wheel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Wheel* Wheel::default_instance_ = NULL;

Wheel* Wheel::New(::google::protobuf::Arena* arena) const {
  Wheel* n = new Wheel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Wheel::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_direction()) {
      direction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    tick_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Wheel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Wheel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Wheel.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_direction;
        break;
      }

      // required string direction = 2;
      case 2: {
        if (tag == 18) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_direction()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->direction().data(), this->direction().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Wheel.direction");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tick;
        break;
      }

      // required int32 tick = 3;
      case 3: {
        if (tag == 24) {
         parse_tick:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tick_)));
          set_has_tick();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Wheel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Wheel)
  return false;
#undef DO_
}

void Wheel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Wheel)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Wheel.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required string direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->direction().data(), this->direction().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Wheel.direction");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->direction(), output);
  }

  // required int32 tick = 3;
  if (has_tick()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->tick(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Wheel)
}

::google::protobuf::uint8* Wheel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Wheel)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Wheel.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required string direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->direction().data(), this->direction().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Wheel.direction");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->direction(), target);
  }

  // required int32 tick = 3;
  if (has_tick()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->tick(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Wheel)
  return target;
}

int Wheel::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_direction()) {
    // required string direction = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->direction());
  }

  if (has_tick()) {
    // required int32 tick = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->tick());
  }

  return total_size;
}
int Wheel::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required string direction = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->direction());

    // required int32 tick = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->tick());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Wheel::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Wheel* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Wheel>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Wheel::MergeFrom(const Wheel& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_direction()) {
      set_has_direction();
      direction_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.direction_);
    }
    if (from.has_tick()) {
      set_tick(from.tick());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Wheel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Wheel::CopyFrom(const Wheel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Wheel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Wheel::Swap(Wheel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Wheel::InternalSwap(Wheel* other) {
  id_.Swap(&other->id_);
  direction_.Swap(&other->direction_);
  std::swap(tick_, other->tick_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Wheel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Wheel_descriptor_;
  metadata.reflection = Wheel_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Wheel

// required string id = 1;
bool Wheel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Wheel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Wheel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Wheel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Wheel::id() const {
  // @@protoc_insertion_point(field_get:Wheel.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Wheel::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Wheel.id)
}
 void Wheel::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Wheel.id)
}
 void Wheel::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Wheel.id)
}
 ::std::string* Wheel::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Wheel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Wheel::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Wheel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Wheel.id)
}

// required string direction = 2;
bool Wheel::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Wheel::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
void Wheel::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
void Wheel::clear_direction() {
  direction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_direction();
}
 const ::std::string& Wheel::direction() const {
  // @@protoc_insertion_point(field_get:Wheel.direction)
  return direction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Wheel::set_direction(const ::std::string& value) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Wheel.direction)
}
 void Wheel::set_direction(const char* value) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Wheel.direction)
}
 void Wheel::set_direction(const char* value, size_t size) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Wheel.direction)
}
 ::std::string* Wheel::mutable_direction() {
  set_has_direction();
  // @@protoc_insertion_point(field_mutable:Wheel.direction)
  return direction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Wheel::release_direction() {
  clear_has_direction();
  return direction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Wheel::set_allocated_direction(::std::string* direction) {
  if (direction != NULL) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  direction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), direction);
  // @@protoc_insertion_point(field_set_allocated:Wheel.direction)
}

// required int32 tick = 3;
bool Wheel::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Wheel::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
void Wheel::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
void Wheel::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
 ::google::protobuf::int32 Wheel::tick() const {
  // @@protoc_insertion_point(field_get:Wheel.tick)
  return tick_;
}
 void Wheel::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:Wheel.tick)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Button::kIdFieldNumber;
const int Button::kStateFieldNumber;
#endif  // !_MSC_VER

Button::Button()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Button)
}

void Button::InitAsDefaultInstance() {
}

Button::Button(const Button& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Button)
}

void Button::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Button::~Button() {
  // @@protoc_insertion_point(destructor:Button)
  SharedDtor();
}

void Button::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Button::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Button::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Button_descriptor_;
}

const Button& Button::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Button* Button::default_instance_ = NULL;

Button* Button::New(::google::protobuf::Arena* arena) const {
  Button* n = new Button;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Button::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_state()) {
      state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Button::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Button)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Button.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_state;
        break;
      }

      // required string state = 2;
      case 2: {
        if (tag == 18) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->state().data(), this->state().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Button.state");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Button)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Button)
  return false;
#undef DO_
}

void Button::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Button)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Button.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required string state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->state().data(), this->state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Button.state");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Button)
}

::google::protobuf::uint8* Button::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Button)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Button.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required string state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->state().data(), this->state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Button.state");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Button)
  return target;
}

int Button::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_state()) {
    // required string state = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->state());
  }

  return total_size;
}
int Button::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required string state = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->state());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Button::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Button* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Button>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Button::MergeFrom(const Button& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_state()) {
      set_has_state();
      state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Button::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Button::CopyFrom(const Button& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Button::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Button::Swap(Button* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Button::InternalSwap(Button* other) {
  id_.Swap(&other->id_);
  state_.Swap(&other->state_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Button::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Button_descriptor_;
  metadata.reflection = Button_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Button

// required string id = 1;
bool Button::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Button::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Button::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Button::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Button::id() const {
  // @@protoc_insertion_point(field_get:Button.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Button::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Button.id)
}
 void Button::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Button.id)
}
 void Button::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Button.id)
}
 ::std::string* Button::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Button.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Button::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Button::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Button.id)
}

// required string state = 2;
bool Button::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Button::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
void Button::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
void Button::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
 const ::std::string& Button::state() const {
  // @@protoc_insertion_point(field_get:Button.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Button::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Button.state)
}
 void Button::set_state(const char* value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Button.state)
}
 void Button::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Button.state)
}
 ::std::string* Button::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:Button.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Button::release_state() {
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Button::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:Button.state)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Mouse::kIdFieldNumber;
const int Mouse::kConnectedFieldNumber;
const int Mouse::kNameFieldNumber;
const int Mouse::kButtonsFieldNumber;
const int Mouse::kWheelsFieldNumber;
#endif  // !_MSC_VER

Mouse::Mouse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mouse)
}

void Mouse::InitAsDefaultInstance() {
}

Mouse::Mouse(const Mouse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mouse)
}

void Mouse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  connected_ = false;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Mouse::~Mouse() {
  // @@protoc_insertion_point(destructor:Mouse)
  SharedDtor();
}

void Mouse::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Mouse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Mouse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Mouse_descriptor_;
}

const Mouse& Mouse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Mouse* Mouse::default_instance_ = NULL;

Mouse* Mouse::New(::google::protobuf::Arena* arena) const {
  Mouse* n = new Mouse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Mouse::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    connected_ = false;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  buttons_.Clear();
  wheels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Mouse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mouse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mouse.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_connected;
        break;
      }

      // required bool connected = 2;
      case 2: {
        if (tag == 16) {
         parse_connected:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
          set_has_connected();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // required string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mouse.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_buttons;
        break;
      }

      // repeated .Button buttons = 4;
      case 4: {
        if (tag == 34) {
         parse_buttons:
          DO_(input->IncrementRecursionDepth());
         parse_loop_buttons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_buttons()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_buttons;
        if (input->ExpectTag(42)) goto parse_loop_wheels;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Wheel wheels = 5;
      case 5: {
        if (tag == 42) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_wheels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_wheels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_wheels;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mouse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mouse)
  return false;
#undef DO_
}

void Mouse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mouse)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mouse.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required bool connected = 2;
  if (has_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->connected(), output);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mouse.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // repeated .Button buttons = 4;
  for (unsigned int i = 0, n = this->buttons_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->buttons(i), output);
  }

  // repeated .Wheel wheels = 5;
  for (unsigned int i = 0, n = this->wheels_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->wheels(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mouse)
}

::google::protobuf::uint8* Mouse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mouse)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mouse.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required bool connected = 2;
  if (has_connected()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->connected(), target);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mouse.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // repeated .Button buttons = 4;
  for (unsigned int i = 0, n = this->buttons_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->buttons(i), target);
  }

  // repeated .Wheel wheels = 5;
  for (unsigned int i = 0, n = this->wheels_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->wheels(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mouse)
  return target;
}

int Mouse::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_connected()) {
    // required bool connected = 2;
    total_size += 1 + 1;
  }

  if (has_name()) {
    // required string name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  return total_size;
}
int Mouse::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required bool connected = 2;
    total_size += 1 + 1;

    // required string name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .Button buttons = 4;
  total_size += 1 * this->buttons_size();
  for (int i = 0; i < this->buttons_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buttons(i));
  }

  // repeated .Wheel wheels = 5;
  total_size += 1 * this->wheels_size();
  for (int i = 0; i < this->wheels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->wheels(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Mouse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Mouse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Mouse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Mouse::MergeFrom(const Mouse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  buttons_.MergeFrom(from.buttons_);
  wheels_.MergeFrom(from.wheels_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_connected()) {
      set_connected(from.connected());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Mouse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Mouse::CopyFrom(const Mouse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mouse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->buttons())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->wheels())) return false;
  return true;
}

void Mouse::Swap(Mouse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Mouse::InternalSwap(Mouse* other) {
  id_.Swap(&other->id_);
  std::swap(connected_, other->connected_);
  name_.Swap(&other->name_);
  buttons_.UnsafeArenaSwap(&other->buttons_);
  wheels_.UnsafeArenaSwap(&other->wheels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Mouse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Mouse_descriptor_;
  metadata.reflection = Mouse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Mouse

// required string id = 1;
bool Mouse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Mouse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Mouse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Mouse::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Mouse::id() const {
  // @@protoc_insertion_point(field_get:Mouse.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mouse::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mouse.id)
}
 void Mouse::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mouse.id)
}
 void Mouse::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mouse.id)
}
 ::std::string* Mouse::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Mouse.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mouse::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mouse::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Mouse.id)
}

// required bool connected = 2;
bool Mouse::has_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Mouse::set_has_connected() {
  _has_bits_[0] |= 0x00000002u;
}
void Mouse::clear_has_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
void Mouse::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
 bool Mouse::connected() const {
  // @@protoc_insertion_point(field_get:Mouse.connected)
  return connected_;
}
 void Mouse::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
  // @@protoc_insertion_point(field_set:Mouse.connected)
}

// required string name = 3;
bool Mouse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Mouse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
void Mouse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void Mouse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Mouse::name() const {
  // @@protoc_insertion_point(field_get:Mouse.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mouse::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mouse.name)
}
 void Mouse::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mouse.name)
}
 void Mouse::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mouse.name)
}
 ::std::string* Mouse::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mouse.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mouse::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mouse::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mouse.name)
}

// repeated .Button buttons = 4;
int Mouse::buttons_size() const {
  return buttons_.size();
}
void Mouse::clear_buttons() {
  buttons_.Clear();
}
 const ::Button& Mouse::buttons(int index) const {
  // @@protoc_insertion_point(field_get:Mouse.buttons)
  return buttons_.Get(index);
}
 ::Button* Mouse::mutable_buttons(int index) {
  // @@protoc_insertion_point(field_mutable:Mouse.buttons)
  return buttons_.Mutable(index);
}
 ::Button* Mouse::add_buttons() {
  // @@protoc_insertion_point(field_add:Mouse.buttons)
  return buttons_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::Button >&
Mouse::buttons() const {
  // @@protoc_insertion_point(field_list:Mouse.buttons)
  return buttons_;
}
 ::google::protobuf::RepeatedPtrField< ::Button >*
Mouse::mutable_buttons() {
  // @@protoc_insertion_point(field_mutable_list:Mouse.buttons)
  return &buttons_;
}

// repeated .Wheel wheels = 5;
int Mouse::wheels_size() const {
  return wheels_.size();
}
void Mouse::clear_wheels() {
  wheels_.Clear();
}
 const ::Wheel& Mouse::wheels(int index) const {
  // @@protoc_insertion_point(field_get:Mouse.wheels)
  return wheels_.Get(index);
}
 ::Wheel* Mouse::mutable_wheels(int index) {
  // @@protoc_insertion_point(field_mutable:Mouse.wheels)
  return wheels_.Mutable(index);
}
 ::Wheel* Mouse::add_wheels() {
  // @@protoc_insertion_point(field_add:Mouse.wheels)
  return wheels_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::Wheel >&
Mouse::wheels() const {
  // @@protoc_insertion_point(field_list:Mouse.wheels)
  return wheels_;
}
 ::google::protobuf::RepeatedPtrField< ::Wheel >*
Mouse::mutable_wheels() {
  // @@protoc_insertion_point(field_mutable_list:Mouse.wheels)
  return &wheels_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DataDescription::kNameFieldNumber;
const int DataDescription::kDdIdFieldNumber;
const int DataDescription::kItemIdFieldNumber;
const int DataDescription::kParentIdFieldNumber;
const int DataDescription::kParentOffsetXFieldNumber;
const int DataDescription::kParentOffsetYFieldNumber;
const int DataDescription::kParentOffsetZFieldNumber;
#endif  // !_MSC_VER

DataDescription::DataDescription()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DataDescription)
}

void DataDescription::InitAsDefaultInstance() {
}

DataDescription::DataDescription(const DataDescription& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DataDescription)
}

void DataDescription::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dd_id_ = 0;
  item_id_ = 0;
  parentid_ = 0;
  parentoffsetx_ = 0;
  parentoffsety_ = 0;
  parentoffsetz_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataDescription::~DataDescription() {
  // @@protoc_insertion_point(destructor:DataDescription)
  SharedDtor();
}

void DataDescription::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void DataDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataDescription::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataDescription_descriptor_;
}

const DataDescription& DataDescription::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

DataDescription* DataDescription::default_instance_ = NULL;

DataDescription* DataDescription::New(::google::protobuf::Arena* arena) const {
  DataDescription* n = new DataDescription;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DataDescription::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DataDescription*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(dd_id_, parentoffsetz_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DataDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DataDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DataDescription.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dd_id;
        break;
      }

      // required int32 dd_id = 2;
      case 2: {
        if (tag == 16) {
         parse_dd_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dd_id_)));
          set_has_dd_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_item_id;
        break;
      }

      // required int32 item_id = 3;
      case 3: {
        if (tag == 24) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_parentId;
        break;
      }

      // required sint32 parentId = 4;
      case 4: {
        if (tag == 32) {
         parse_parentId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_parentOffsetX;
        break;
      }

      // required sint32 parentOffsetX = 5;
      case 5: {
        if (tag == 40) {
         parse_parentOffsetX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &parentoffsetx_)));
          set_has_parentoffsetx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_parentOffsetY;
        break;
      }

      // required sint32 parentOffsetY = 6;
      case 6: {
        if (tag == 48) {
         parse_parentOffsetY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &parentoffsety_)));
          set_has_parentoffsety();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_parentOffsetZ;
        break;
      }

      // required sint32 parentOffsetZ = 7;
      case 7: {
        if (tag == 56) {
         parse_parentOffsetZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &parentoffsetz_)));
          set_has_parentoffsetz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DataDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DataDescription)
  return false;
#undef DO_
}

void DataDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DataDescription)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DataDescription.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required int32 dd_id = 2;
  if (has_dd_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->dd_id(), output);
  }

  // required int32 item_id = 3;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->item_id(), output);
  }

  // required sint32 parentId = 4;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->parentid(), output);
  }

  // required sint32 parentOffsetX = 5;
  if (has_parentoffsetx()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->parentoffsetx(), output);
  }

  // required sint32 parentOffsetY = 6;
  if (has_parentoffsety()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(6, this->parentoffsety(), output);
  }

  // required sint32 parentOffsetZ = 7;
  if (has_parentoffsetz()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(7, this->parentoffsetz(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DataDescription)
}

::google::protobuf::uint8* DataDescription::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataDescription)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DataDescription.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required int32 dd_id = 2;
  if (has_dd_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->dd_id(), target);
  }

  // required int32 item_id = 3;
  if (has_item_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->item_id(), target);
  }

  // required sint32 parentId = 4;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->parentid(), target);
  }

  // required sint32 parentOffsetX = 5;
  if (has_parentoffsetx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->parentoffsetx(), target);
  }

  // required sint32 parentOffsetY = 6;
  if (has_parentoffsety()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(6, this->parentoffsety(), target);
  }

  // required sint32 parentOffsetZ = 7;
  if (has_parentoffsetz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(7, this->parentoffsetz(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataDescription)
  return target;
}

int DataDescription::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_dd_id()) {
    // required int32 dd_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->dd_id());
  }

  if (has_item_id()) {
    // required int32 item_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->item_id());
  }

  if (has_parentid()) {
    // required sint32 parentId = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentid());
  }

  if (has_parentoffsetx()) {
    // required sint32 parentOffsetX = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsetx());
  }

  if (has_parentoffsety()) {
    // required sint32 parentOffsetY = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsety());
  }

  if (has_parentoffsetz()) {
    // required sint32 parentOffsetZ = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsetz());
  }

  return total_size;
}
int DataDescription::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required int32 dd_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->dd_id());

    // required int32 item_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->item_id());

    // required sint32 parentId = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentid());

    // required sint32 parentOffsetX = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsetx());

    // required sint32 parentOffsetY = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsety());

    // required sint32 parentOffsetZ = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->parentoffsetz());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataDescription::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DataDescription* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DataDescription>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataDescription::MergeFrom(const DataDescription& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_dd_id()) {
      set_dd_id(from.dd_id());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
    if (from.has_parentoffsetx()) {
      set_parentoffsetx(from.parentoffsetx());
    }
    if (from.has_parentoffsety()) {
      set_parentoffsety(from.parentoffsety());
    }
    if (from.has_parentoffsetz()) {
      set_parentoffsetz(from.parentoffsetz());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DataDescription::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataDescription::CopyFrom(const DataDescription& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataDescription::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void DataDescription::Swap(DataDescription* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DataDescription::InternalSwap(DataDescription* other) {
  name_.Swap(&other->name_);
  std::swap(dd_id_, other->dd_id_);
  std::swap(item_id_, other->item_id_);
  std::swap(parentid_, other->parentid_);
  std::swap(parentoffsetx_, other->parentoffsetx_);
  std::swap(parentoffsety_, other->parentoffsety_);
  std::swap(parentoffsetz_, other->parentoffsetz_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DataDescription::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataDescription_descriptor_;
  metadata.reflection = DataDescription_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DataDescription

// required string name = 1;
bool DataDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DataDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void DataDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void DataDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& DataDescription::name() const {
  // @@protoc_insertion_point(field_get:DataDescription.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataDescription::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataDescription.name)
}
 void DataDescription::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataDescription.name)
}
 void DataDescription::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataDescription.name)
}
 ::std::string* DataDescription::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:DataDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DataDescription::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DataDescription.name)
}

// required int32 dd_id = 2;
bool DataDescription::has_dd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DataDescription::set_has_dd_id() {
  _has_bits_[0] |= 0x00000002u;
}
void DataDescription::clear_has_dd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void DataDescription::clear_dd_id() {
  dd_id_ = 0;
  clear_has_dd_id();
}
 ::google::protobuf::int32 DataDescription::dd_id() const {
  // @@protoc_insertion_point(field_get:DataDescription.dd_id)
  return dd_id_;
}
 void DataDescription::set_dd_id(::google::protobuf::int32 value) {
  set_has_dd_id();
  dd_id_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.dd_id)
}

// required int32 item_id = 3;
bool DataDescription::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DataDescription::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
void DataDescription::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void DataDescription::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
 ::google::protobuf::int32 DataDescription::item_id() const {
  // @@protoc_insertion_point(field_get:DataDescription.item_id)
  return item_id_;
}
 void DataDescription::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.item_id)
}

// required sint32 parentId = 4;
bool DataDescription::has_parentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DataDescription::set_has_parentid() {
  _has_bits_[0] |= 0x00000008u;
}
void DataDescription::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000008u;
}
void DataDescription::clear_parentid() {
  parentid_ = 0;
  clear_has_parentid();
}
 ::google::protobuf::int32 DataDescription::parentid() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentId)
  return parentid_;
}
 void DataDescription::set_parentid(::google::protobuf::int32 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentId)
}

// required sint32 parentOffsetX = 5;
bool DataDescription::has_parentoffsetx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DataDescription::set_has_parentoffsetx() {
  _has_bits_[0] |= 0x00000010u;
}
void DataDescription::clear_has_parentoffsetx() {
  _has_bits_[0] &= ~0x00000010u;
}
void DataDescription::clear_parentoffsetx() {
  parentoffsetx_ = 0;
  clear_has_parentoffsetx();
}
 ::google::protobuf::int32 DataDescription::parentoffsetx() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetX)
  return parentoffsetx_;
}
 void DataDescription::set_parentoffsetx(::google::protobuf::int32 value) {
  set_has_parentoffsetx();
  parentoffsetx_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetX)
}

// required sint32 parentOffsetY = 6;
bool DataDescription::has_parentoffsety() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DataDescription::set_has_parentoffsety() {
  _has_bits_[0] |= 0x00000020u;
}
void DataDescription::clear_has_parentoffsety() {
  _has_bits_[0] &= ~0x00000020u;
}
void DataDescription::clear_parentoffsety() {
  parentoffsety_ = 0;
  clear_has_parentoffsety();
}
 ::google::protobuf::int32 DataDescription::parentoffsety() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetY)
  return parentoffsety_;
}
 void DataDescription::set_parentoffsety(::google::protobuf::int32 value) {
  set_has_parentoffsety();
  parentoffsety_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetY)
}

// required sint32 parentOffsetZ = 7;
bool DataDescription::has_parentoffsetz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DataDescription::set_has_parentoffsetz() {
  _has_bits_[0] |= 0x00000040u;
}
void DataDescription::clear_has_parentoffsetz() {
  _has_bits_[0] &= ~0x00000040u;
}
void DataDescription::clear_parentoffsetz() {
  parentoffsetz_ = 0;
  clear_has_parentoffsetz();
}
 ::google::protobuf::int32 DataDescription::parentoffsetz() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetZ)
  return parentoffsetz_;
}
 void DataDescription::set_parentoffsetz(::google::protobuf::int32 value) {
  set_has_parentoffsetz();
  parentoffsetz_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetZ)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int LabeledMarker::kIdFieldNumber;
const int LabeledMarker::kSizeFieldNumber;
const int LabeledMarker::kPositionFieldNumber;
#endif  // !_MSC_VER

LabeledMarker::LabeledMarker()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LabeledMarker)
}

void LabeledMarker::InitAsDefaultInstance() {
  position_ = const_cast< ::Position*>(&::Position::default_instance());
}

LabeledMarker::LabeledMarker(const LabeledMarker& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LabeledMarker)
}

void LabeledMarker::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  size_ = 0;
  position_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LabeledMarker::~LabeledMarker() {
  // @@protoc_insertion_point(destructor:LabeledMarker)
  SharedDtor();
}

void LabeledMarker::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
  }
}

void LabeledMarker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LabeledMarker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LabeledMarker_descriptor_;
}

const LabeledMarker& LabeledMarker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

LabeledMarker* LabeledMarker::default_instance_ = NULL;

LabeledMarker* LabeledMarker::New(::google::protobuf::Arena* arena) const {
  LabeledMarker* n = new LabeledMarker;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LabeledMarker::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    id_ = 0;
    size_ = 0;
    if (has_position()) {
      if (position_ != NULL) position_->::Position::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LabeledMarker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LabeledMarker)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_size;
        break;
      }

      // required double size = 2;
      case 2: {
        if (tag == 17) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }

      // required .Position position = 3;
      case 3: {
        if (tag == 26) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LabeledMarker)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LabeledMarker)
  return false;
#undef DO_
}

void LabeledMarker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LabeledMarker)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required double size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->size(), output);
  }

  // required .Position position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->position_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LabeledMarker)
}

::google::protobuf::uint8* LabeledMarker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LabeledMarker)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required double size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->size(), target);
  }

  // required .Position position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->position_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LabeledMarker)
  return target;
}

int LabeledMarker::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  if (has_size()) {
    // required double size = 2;
    total_size += 1 + 8;
  }

  if (has_position()) {
    // required .Position position = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  return total_size;
}
int LabeledMarker::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());

    // required double size = 2;
    total_size += 1 + 8;

    // required .Position position = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LabeledMarker::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LabeledMarker* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LabeledMarker>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LabeledMarker::MergeFrom(const LabeledMarker& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_position()) {
      mutable_position()->::Position::MergeFrom(from.position());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LabeledMarker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LabeledMarker::CopyFrom(const LabeledMarker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LabeledMarker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  return true;
}

void LabeledMarker::Swap(LabeledMarker* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LabeledMarker::InternalSwap(LabeledMarker* other) {
  std::swap(id_, other->id_);
  std::swap(size_, other->size_);
  std::swap(position_, other->position_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LabeledMarker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LabeledMarker_descriptor_;
  metadata.reflection = LabeledMarker_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LabeledMarker

// required int32 id = 1;
bool LabeledMarker::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LabeledMarker::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void LabeledMarker::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void LabeledMarker::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::google::protobuf::int32 LabeledMarker::id() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.id)
  return id_;
}
 void LabeledMarker::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:LabeledMarker.id)
}

// required double size = 2;
bool LabeledMarker::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LabeledMarker::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
void LabeledMarker::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void LabeledMarker::clear_size() {
  size_ = 0;
  clear_has_size();
}
 double LabeledMarker::size() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.size)
  return size_;
}
 void LabeledMarker::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:LabeledMarker.size)
}

// required .Position position = 3;
bool LabeledMarker::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LabeledMarker::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
void LabeledMarker::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
void LabeledMarker::clear_position() {
  if (position_ != NULL) position_->::Position::Clear();
  clear_has_position();
}
 const ::Position& LabeledMarker::position() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
 ::Position* LabeledMarker::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Position;
  }
  // @@protoc_insertion_point(field_mutable:LabeledMarker.position)
  return position_;
}
 ::Position* LabeledMarker::release_position() {
  clear_has_position();
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
 void LabeledMarker::set_allocated_position(::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:LabeledMarker.position)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TrackedBody::kIdFieldNumber;
const int TrackedBody::kLabelFieldNumber;
const int TrackedBody::kTrackingValidFieldNumber;
const int TrackedBody::kPositionFieldNumber;
const int TrackedBody::kRotationFieldNumber;
const int TrackedBody::kMeanErrorFieldNumber;
const int TrackedBody::kMarkersFieldNumber;
#endif  // !_MSC_VER

TrackedBody::TrackedBody()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrackedBody)
}

void TrackedBody::InitAsDefaultInstance() {
  position_ = const_cast< ::Position*>(&::Position::default_instance());
  rotation_ = const_cast< ::Rotation*>(&::Rotation::default_instance());
}

TrackedBody::TrackedBody(const TrackedBody& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TrackedBody)
}

void TrackedBody::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0;
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trackingvalid_ = false;
  position_ = NULL;
  rotation_ = NULL;
  meanerror_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrackedBody::~TrackedBody() {
  // @@protoc_insertion_point(destructor:TrackedBody)
  SharedDtor();
}

void TrackedBody::SharedDtor() {
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete position_;
    delete rotation_;
  }
}

void TrackedBody::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrackedBody::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrackedBody_descriptor_;
}

const TrackedBody& TrackedBody::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

TrackedBody* TrackedBody::default_instance_ = NULL;

TrackedBody* TrackedBody::New(::google::protobuf::Arena* arena) const {
  TrackedBody* n = new TrackedBody;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrackedBody::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrackedBody*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(id_, trackingvalid_);
    if (has_label()) {
      label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_position()) {
      if (position_ != NULL) position_->::Position::Clear();
    }
    if (has_rotation()) {
      if (rotation_ != NULL) rotation_->::Rotation::Clear();
    }
    meanerror_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  markers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrackedBody::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrackedBody)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_label;
        break;
      }

      // required string label = 2;
      case 2: {
        if (tag == 18) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrackedBody.label");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_trackingValid;
        break;
      }

      // required bool trackingValid = 3;
      case 3: {
        if (tag == 24) {
         parse_trackingValid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &trackingvalid_)));
          set_has_trackingvalid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_position;
        break;
      }

      // required .Position position = 4;
      case 4: {
        if (tag == 34) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_rotation;
        break;
      }

      // required .Rotation rotation = 5;
      case 5: {
        if (tag == 42) {
         parse_rotation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rotation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_meanError;
        break;
      }

      // optional float meanError = 6;
      case 6: {
        if (tag == 53) {
         parse_meanError:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &meanerror_)));
          set_has_meanerror();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_markers;
        break;
      }

      // repeated .LabeledMarker markers = 7;
      case 7: {
        if (tag == 58) {
         parse_markers:
          DO_(input->IncrementRecursionDepth());
         parse_loop_markers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_markers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_markers;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrackedBody)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrackedBody)
  return false;
#undef DO_
}

void TrackedBody::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrackedBody)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrackedBody.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->label(), output);
  }

  // required bool trackingValid = 3;
  if (has_trackingvalid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->trackingvalid(), output);
  }

  // required .Position position = 4;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->position_, output);
  }

  // required .Rotation rotation = 5;
  if (has_rotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->rotation_, output);
  }

  // optional float meanError = 6;
  if (has_meanerror()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->meanerror(), output);
  }

  // repeated .LabeledMarker markers = 7;
  for (unsigned int i = 0, n = this->markers_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->markers(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrackedBody)
}

::google::protobuf::uint8* TrackedBody::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrackedBody)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrackedBody.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->label(), target);
  }

  // required bool trackingValid = 3;
  if (has_trackingvalid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->trackingvalid(), target);
  }

  // required .Position position = 4;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->position_, target);
  }

  // required .Rotation rotation = 5;
  if (has_rotation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->rotation_, target);
  }

  // optional float meanError = 6;
  if (has_meanerror()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->meanerror(), target);
  }

  // repeated .LabeledMarker markers = 7;
  for (unsigned int i = 0, n = this->markers_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->markers(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrackedBody)
  return target;
}

int TrackedBody::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  if (has_label()) {
    // required string label = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->label());
  }

  if (has_trackingvalid()) {
    // required bool trackingValid = 3;
    total_size += 1 + 1;
  }

  if (has_position()) {
    // required .Position position = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  if (has_rotation()) {
    // required .Rotation rotation = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->rotation_);
  }

  return total_size;
}
int TrackedBody::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());

    // required string label = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->label());

    // required bool trackingValid = 3;
    total_size += 1 + 1;

    // required .Position position = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

    // required .Rotation rotation = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->rotation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional float meanError = 6;
  if (has_meanerror()) {
    total_size += 1 + 4;
  }

  // repeated .LabeledMarker markers = 7;
  total_size += 1 * this->markers_size();
  for (int i = 0; i < this->markers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->markers(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrackedBody::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TrackedBody* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrackedBody>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrackedBody::MergeFrom(const TrackedBody& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  markers_.MergeFrom(from.markers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_label()) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (from.has_trackingvalid()) {
      set_trackingvalid(from.trackingvalid());
    }
    if (from.has_position()) {
      mutable_position()->::Position::MergeFrom(from.position());
    }
    if (from.has_rotation()) {
      mutable_rotation()->::Rotation::MergeFrom(from.rotation());
    }
    if (from.has_meanerror()) {
      set_meanerror(from.meanerror());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrackedBody::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackedBody::CopyFrom(const TrackedBody& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackedBody::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_rotation()) {
    if (!this->rotation_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->markers())) return false;
  return true;
}

void TrackedBody::Swap(TrackedBody* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrackedBody::InternalSwap(TrackedBody* other) {
  std::swap(id_, other->id_);
  label_.Swap(&other->label_);
  std::swap(trackingvalid_, other->trackingvalid_);
  std::swap(position_, other->position_);
  std::swap(rotation_, other->rotation_);
  std::swap(meanerror_, other->meanerror_);
  markers_.UnsafeArenaSwap(&other->markers_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrackedBody::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrackedBody_descriptor_;
  metadata.reflection = TrackedBody_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackedBody

// required int32 id = 1;
bool TrackedBody::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrackedBody::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TrackedBody::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrackedBody::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::google::protobuf::int32 TrackedBody::id() const {
  // @@protoc_insertion_point(field_get:TrackedBody.id)
  return id_;
}
 void TrackedBody::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.id)
}

// required string label = 2;
bool TrackedBody::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrackedBody::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
void TrackedBody::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrackedBody::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
 const ::std::string& TrackedBody::label() const {
  // @@protoc_insertion_point(field_get:TrackedBody.label)
  return label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrackedBody::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrackedBody.label)
}
 void TrackedBody::set_label(const char* value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrackedBody.label)
}
 void TrackedBody::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrackedBody.label)
}
 ::std::string* TrackedBody::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrackedBody.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TrackedBody::release_label() {
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrackedBody::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.label)
}

// required bool trackingValid = 3;
bool TrackedBody::has_trackingvalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TrackedBody::set_has_trackingvalid() {
  _has_bits_[0] |= 0x00000004u;
}
void TrackedBody::clear_has_trackingvalid() {
  _has_bits_[0] &= ~0x00000004u;
}
void TrackedBody::clear_trackingvalid() {
  trackingvalid_ = false;
  clear_has_trackingvalid();
}
 bool TrackedBody::trackingvalid() const {
  // @@protoc_insertion_point(field_get:TrackedBody.trackingValid)
  return trackingvalid_;
}
 void TrackedBody::set_trackingvalid(bool value) {
  set_has_trackingvalid();
  trackingvalid_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.trackingValid)
}

// required .Position position = 4;
bool TrackedBody::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TrackedBody::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
void TrackedBody::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
void TrackedBody::clear_position() {
  if (position_ != NULL) position_->::Position::Clear();
  clear_has_position();
}
 const ::Position& TrackedBody::position() const {
  // @@protoc_insertion_point(field_get:TrackedBody.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
 ::Position* TrackedBody::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Position;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBody.position)
  return position_;
}
 ::Position* TrackedBody::release_position() {
  clear_has_position();
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
 void TrackedBody::set_allocated_position(::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.position)
}

// required .Rotation rotation = 5;
bool TrackedBody::has_rotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TrackedBody::set_has_rotation() {
  _has_bits_[0] |= 0x00000010u;
}
void TrackedBody::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000010u;
}
void TrackedBody::clear_rotation() {
  if (rotation_ != NULL) rotation_->::Rotation::Clear();
  clear_has_rotation();
}
 const ::Rotation& TrackedBody::rotation() const {
  // @@protoc_insertion_point(field_get:TrackedBody.rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
 ::Rotation* TrackedBody::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Rotation;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBody.rotation)
  return rotation_;
}
 ::Rotation* TrackedBody::release_rotation() {
  clear_has_rotation();
  ::Rotation* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
 void TrackedBody::set_allocated_rotation(::Rotation* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.rotation)
}

// optional float meanError = 6;
bool TrackedBody::has_meanerror() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TrackedBody::set_has_meanerror() {
  _has_bits_[0] |= 0x00000020u;
}
void TrackedBody::clear_has_meanerror() {
  _has_bits_[0] &= ~0x00000020u;
}
void TrackedBody::clear_meanerror() {
  meanerror_ = 0;
  clear_has_meanerror();
}
 float TrackedBody::meanerror() const {
  // @@protoc_insertion_point(field_get:TrackedBody.meanError)
  return meanerror_;
}
 void TrackedBody::set_meanerror(float value) {
  set_has_meanerror();
  meanerror_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.meanError)
}

// repeated .LabeledMarker markers = 7;
int TrackedBody::markers_size() const {
  return markers_.size();
}
void TrackedBody::clear_markers() {
  markers_.Clear();
}
 const ::LabeledMarker& TrackedBody::markers(int index) const {
  // @@protoc_insertion_point(field_get:TrackedBody.markers)
  return markers_.Get(index);
}
 ::LabeledMarker* TrackedBody::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:TrackedBody.markers)
  return markers_.Mutable(index);
}
 ::LabeledMarker* TrackedBody::add_markers() {
  // @@protoc_insertion_point(field_add:TrackedBody.markers)
  return markers_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::LabeledMarker >&
TrackedBody::markers() const {
  // @@protoc_insertion_point(field_list:TrackedBody.markers)
  return markers_;
}
 ::google::protobuf::RepeatedPtrField< ::LabeledMarker >*
TrackedBody::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:TrackedBody.markers)
  return &markers_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Mocap::kDuringRecordingFieldNumber;
const int Mocap::kTrackedModelsChangedFieldNumber;
const int Mocap::kTimecodeFieldNumber;
const int Mocap::kTrackedBodiesFieldNumber;
#endif  // !_MSC_VER

Mocap::Mocap()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mocap)
}

void Mocap::InitAsDefaultInstance() {
}

Mocap::Mocap(const Mocap& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Mocap)
}

void Mocap::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  duringrecording_ = false;
  trackedmodelschanged_ = false;
  timecode_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Mocap::~Mocap() {
  // @@protoc_insertion_point(destructor:Mocap)
  SharedDtor();
}

void Mocap::SharedDtor() {
  timecode_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Mocap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Mocap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Mocap_descriptor_;
}

const Mocap& Mocap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Mocap* Mocap::default_instance_ = NULL;

Mocap* Mocap::New(::google::protobuf::Arena* arena) const {
  Mocap* n = new Mocap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Mocap::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Mocap*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(duringrecording_, trackedmodelschanged_);
    if (has_timecode()) {
      timecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  tracked_bodies_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Mocap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mocap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool duringRecording = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &duringrecording_)));
          set_has_duringrecording();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_trackedModelsChanged;
        break;
      }

      // required bool trackedModelsChanged = 2;
      case 2: {
        if (tag == 16) {
         parse_trackedModelsChanged:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &trackedmodelschanged_)));
          set_has_trackedmodelschanged();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_timecode;
        break;
      }

      // optional string timecode = 3;
      case 3: {
        if (tag == 26) {
         parse_timecode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_timecode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->timecode().data(), this->timecode().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mocap.timecode");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_tracked_bodies;
        break;
      }

      // repeated .TrackedBody tracked_bodies = 4;
      case 4: {
        if (tag == 34) {
         parse_tracked_bodies:
          DO_(input->IncrementRecursionDepth());
         parse_loop_tracked_bodies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_tracked_bodies()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_tracked_bodies;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mocap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mocap)
  return false;
#undef DO_
}

void Mocap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mocap)
  // required bool duringRecording = 1;
  if (has_duringrecording()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->duringrecording(), output);
  }

  // required bool trackedModelsChanged = 2;
  if (has_trackedmodelschanged()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->trackedmodelschanged(), output);
  }

  // optional string timecode = 3;
  if (has_timecode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->timecode().data(), this->timecode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mocap.timecode");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->timecode(), output);
  }

  // repeated .TrackedBody tracked_bodies = 4;
  for (unsigned int i = 0, n = this->tracked_bodies_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->tracked_bodies(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mocap)
}

::google::protobuf::uint8* Mocap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mocap)
  // required bool duringRecording = 1;
  if (has_duringrecording()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->duringrecording(), target);
  }

  // required bool trackedModelsChanged = 2;
  if (has_trackedmodelschanged()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->trackedmodelschanged(), target);
  }

  // optional string timecode = 3;
  if (has_timecode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->timecode().data(), this->timecode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mocap.timecode");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->timecode(), target);
  }

  // repeated .TrackedBody tracked_bodies = 4;
  for (unsigned int i = 0, n = this->tracked_bodies_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->tracked_bodies(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mocap)
  return target;
}

int Mocap::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_duringrecording()) {
    // required bool duringRecording = 1;
    total_size += 1 + 1;
  }

  if (has_trackedmodelschanged()) {
    // required bool trackedModelsChanged = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
int Mocap::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bool duringRecording = 1;
    total_size += 1 + 1;

    // required bool trackedModelsChanged = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string timecode = 3;
  if (has_timecode()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->timecode());
  }

  // repeated .TrackedBody tracked_bodies = 4;
  total_size += 1 * this->tracked_bodies_size();
  for (int i = 0; i < this->tracked_bodies_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracked_bodies(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Mocap::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Mocap* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Mocap>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Mocap::MergeFrom(const Mocap& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  tracked_bodies_.MergeFrom(from.tracked_bodies_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_duringrecording()) {
      set_duringrecording(from.duringrecording());
    }
    if (from.has_trackedmodelschanged()) {
      set_trackedmodelschanged(from.trackedmodelschanged());
    }
    if (from.has_timecode()) {
      set_has_timecode();
      timecode_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.timecode_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Mocap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Mocap::CopyFrom(const Mocap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mocap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->tracked_bodies())) return false;
  return true;
}

void Mocap::Swap(Mocap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Mocap::InternalSwap(Mocap* other) {
  std::swap(duringrecording_, other->duringrecording_);
  std::swap(trackedmodelschanged_, other->trackedmodelschanged_);
  timecode_.Swap(&other->timecode_);
  tracked_bodies_.UnsafeArenaSwap(&other->tracked_bodies_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Mocap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Mocap_descriptor_;
  metadata.reflection = Mocap_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Mocap

// required bool duringRecording = 1;
bool Mocap::has_duringrecording() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Mocap::set_has_duringrecording() {
  _has_bits_[0] |= 0x00000001u;
}
void Mocap::clear_has_duringrecording() {
  _has_bits_[0] &= ~0x00000001u;
}
void Mocap::clear_duringrecording() {
  duringrecording_ = false;
  clear_has_duringrecording();
}
 bool Mocap::duringrecording() const {
  // @@protoc_insertion_point(field_get:Mocap.duringRecording)
  return duringrecording_;
}
 void Mocap::set_duringrecording(bool value) {
  set_has_duringrecording();
  duringrecording_ = value;
  // @@protoc_insertion_point(field_set:Mocap.duringRecording)
}

// required bool trackedModelsChanged = 2;
bool Mocap::has_trackedmodelschanged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Mocap::set_has_trackedmodelschanged() {
  _has_bits_[0] |= 0x00000002u;
}
void Mocap::clear_has_trackedmodelschanged() {
  _has_bits_[0] &= ~0x00000002u;
}
void Mocap::clear_trackedmodelschanged() {
  trackedmodelschanged_ = false;
  clear_has_trackedmodelschanged();
}
 bool Mocap::trackedmodelschanged() const {
  // @@protoc_insertion_point(field_get:Mocap.trackedModelsChanged)
  return trackedmodelschanged_;
}
 void Mocap::set_trackedmodelschanged(bool value) {
  set_has_trackedmodelschanged();
  trackedmodelschanged_ = value;
  // @@protoc_insertion_point(field_set:Mocap.trackedModelsChanged)
}

// optional string timecode = 3;
bool Mocap::has_timecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Mocap::set_has_timecode() {
  _has_bits_[0] |= 0x00000004u;
}
void Mocap::clear_has_timecode() {
  _has_bits_[0] &= ~0x00000004u;
}
void Mocap::clear_timecode() {
  timecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timecode();
}
 const ::std::string& Mocap::timecode() const {
  // @@protoc_insertion_point(field_get:Mocap.timecode)
  return timecode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mocap::set_timecode(const ::std::string& value) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mocap.timecode)
}
 void Mocap::set_timecode(const char* value) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mocap.timecode)
}
 void Mocap::set_timecode(const char* value, size_t size) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mocap.timecode)
}
 ::std::string* Mocap::mutable_timecode() {
  set_has_timecode();
  // @@protoc_insertion_point(field_mutable:Mocap.timecode)
  return timecode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mocap::release_timecode() {
  clear_has_timecode();
  return timecode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mocap::set_allocated_timecode(::std::string* timecode) {
  if (timecode != NULL) {
    set_has_timecode();
  } else {
    clear_has_timecode();
  }
  timecode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timecode);
  // @@protoc_insertion_point(field_set_allocated:Mocap.timecode)
}

// repeated .TrackedBody tracked_bodies = 4;
int Mocap::tracked_bodies_size() const {
  return tracked_bodies_.size();
}
void Mocap::clear_tracked_bodies() {
  tracked_bodies_.Clear();
}
 const ::TrackedBody& Mocap::tracked_bodies(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.tracked_bodies)
  return tracked_bodies_.Get(index);
}
 ::TrackedBody* Mocap::mutable_tracked_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.tracked_bodies)
  return tracked_bodies_.Mutable(index);
}
 ::TrackedBody* Mocap::add_tracked_bodies() {
  // @@protoc_insertion_point(field_add:Mocap.tracked_bodies)
  return tracked_bodies_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::TrackedBody >&
Mocap::tracked_bodies() const {
  // @@protoc_insertion_point(field_list:Mocap.tracked_bodies)
  return tracked_bodies_;
}
 ::google::protobuf::RepeatedPtrField< ::TrackedBody >*
Mocap::mutable_tracked_bodies() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.tracked_bodies)
  return &tracked_bodies_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Update::kIdFieldNumber;
const int Update::kModVersionFieldNumber;
const int Update::kTimeFieldNumber;
const int Update::kMocapFieldNumber;
const int Update::kMiceFieldNumber;
const int Update::kStrokesFieldNumber;
#endif  // !_MSC_VER

Update::Update()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Update)
}

void Update::InitAsDefaultInstance() {
  mocap_ = const_cast< ::Mocap*>(&::Mocap::default_instance());
}

Update::Update(const Update& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Update)
}

void Update::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mod_version_ = 0;
  time_ = 0;
  mocap_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Update)
  SharedDtor();
}

void Update::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete mocap_;
  }
}

void Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Update::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Update_descriptor_;
}

const Update& Update::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Update* Update::default_instance_ = NULL;

Update* Update::New(::google::protobuf::Arena* arena) const {
  Update* n = new Update;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Update::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Update*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(mod_version_, time_);
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_mocap()) {
      if (mocap_ != NULL) mocap_->::Mocap::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  mice_.Clear();
  strokes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Update)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Update.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mod_version;
        break;
      }

      // required int32 mod_version = 2;
      case 2: {
        if (tag == 16) {
         parse_mod_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mod_version_)));
          set_has_mod_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time;
        break;
      }

      // required int32 time = 3;
      case 3: {
        if (tag == 24) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mocap;
        break;
      }

      // optional .Mocap mocap = 4;
      case 4: {
        if (tag == 34) {
         parse_mocap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mocap()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mice;
        break;
      }

      // repeated .Mouse mice = 5;
      case 5: {
        if (tag == 42) {
         parse_mice:
          DO_(input->IncrementRecursionDepth());
         parse_loop_mice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_mice;
        if (input->ExpectTag(50)) goto parse_loop_strokes;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Position strokes = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_strokes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_strokes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_strokes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Update)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Update.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required int32 mod_version = 2;
  if (has_mod_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mod_version(), output);
  }

  // required int32 time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->time(), output);
  }

  // optional .Mocap mocap = 4;
  if (has_mocap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->mocap_, output);
  }

  // repeated .Mouse mice = 5;
  for (unsigned int i = 0, n = this->mice_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->mice(i), output);
  }

  // repeated .Position strokes = 6;
  for (unsigned int i = 0, n = this->strokes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->strokes(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Update)
}

::google::protobuf::uint8* Update::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Update)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Update.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required int32 mod_version = 2;
  if (has_mod_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->mod_version(), target);
  }

  // required int32 time = 3;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->time(), target);
  }

  // optional .Mocap mocap = 4;
  if (has_mocap()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->mocap_, target);
  }

  // repeated .Mouse mice = 5;
  for (unsigned int i = 0, n = this->mice_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->mice(i), target);
  }

  // repeated .Position strokes = 6;
  for (unsigned int i = 0, n = this->strokes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->strokes(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Update)
  return target;
}

int Update::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_mod_version()) {
    // required int32 mod_version = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mod_version());
  }

  if (has_time()) {
    // required int32 time = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->time());
  }

  return total_size;
}
int Update::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required int32 mod_version = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mod_version());

    // required int32 time = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .Mocap mocap = 4;
  if (has_mocap()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->mocap_);
  }

  // repeated .Mouse mice = 5;
  total_size += 1 * this->mice_size();
  for (int i = 0; i < this->mice_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mice(i));
  }

  // repeated .Position strokes = 6;
  total_size += 1 * this->strokes_size();
  for (int i = 0; i < this->strokes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->strokes(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Update::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Update* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Update>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Update::MergeFrom(const Update& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  mice_.MergeFrom(from.mice_);
  strokes_.MergeFrom(from.strokes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_mod_version()) {
      set_mod_version(from.mod_version());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_mocap()) {
      mutable_mocap()->::Mocap::MergeFrom(from.mocap());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Update::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Update::CopyFrom(const Update& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_mocap()) {
    if (!this->mocap_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->mice())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->strokes())) return false;
  return true;
}

void Update::Swap(Update* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Update::InternalSwap(Update* other) {
  id_.Swap(&other->id_);
  std::swap(mod_version_, other->mod_version_);
  std::swap(time_, other->time_);
  std::swap(mocap_, other->mocap_);
  mice_.UnsafeArenaSwap(&other->mice_);
  strokes_.UnsafeArenaSwap(&other->strokes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Update::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Update_descriptor_;
  metadata.reflection = Update_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Update

// required string id = 1;
bool Update::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Update::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Update::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Update::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Update::id() const {
  // @@protoc_insertion_point(field_get:Update.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Update::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Update.id)
}
 void Update::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Update.id)
}
 void Update::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Update.id)
}
 ::std::string* Update::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Update.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Update::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Update::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Update.id)
}

// required int32 mod_version = 2;
bool Update::has_mod_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Update::set_has_mod_version() {
  _has_bits_[0] |= 0x00000002u;
}
void Update::clear_has_mod_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void Update::clear_mod_version() {
  mod_version_ = 0;
  clear_has_mod_version();
}
 ::google::protobuf::int32 Update::mod_version() const {
  // @@protoc_insertion_point(field_get:Update.mod_version)
  return mod_version_;
}
 void Update::set_mod_version(::google::protobuf::int32 value) {
  set_has_mod_version();
  mod_version_ = value;
  // @@protoc_insertion_point(field_set:Update.mod_version)
}

// required int32 time = 3;
bool Update::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Update::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
void Update::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
void Update::clear_time() {
  time_ = 0;
  clear_has_time();
}
 ::google::protobuf::int32 Update::time() const {
  // @@protoc_insertion_point(field_get:Update.time)
  return time_;
}
 void Update::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Update.time)
}

// optional .Mocap mocap = 4;
bool Update::has_mocap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Update::set_has_mocap() {
  _has_bits_[0] |= 0x00000008u;
}
void Update::clear_has_mocap() {
  _has_bits_[0] &= ~0x00000008u;
}
void Update::clear_mocap() {
  if (mocap_ != NULL) mocap_->::Mocap::Clear();
  clear_has_mocap();
}
 const ::Mocap& Update::mocap() const {
  // @@protoc_insertion_point(field_get:Update.mocap)
  return mocap_ != NULL ? *mocap_ : *default_instance_->mocap_;
}
 ::Mocap* Update::mutable_mocap() {
  set_has_mocap();
  if (mocap_ == NULL) {
    mocap_ = new ::Mocap;
  }
  // @@protoc_insertion_point(field_mutable:Update.mocap)
  return mocap_;
}
 ::Mocap* Update::release_mocap() {
  clear_has_mocap();
  ::Mocap* temp = mocap_;
  mocap_ = NULL;
  return temp;
}
 void Update::set_allocated_mocap(::Mocap* mocap) {
  delete mocap_;
  mocap_ = mocap;
  if (mocap) {
    set_has_mocap();
  } else {
    clear_has_mocap();
  }
  // @@protoc_insertion_point(field_set_allocated:Update.mocap)
}

// repeated .Mouse mice = 5;
int Update::mice_size() const {
  return mice_.size();
}
void Update::clear_mice() {
  mice_.Clear();
}
 const ::Mouse& Update::mice(int index) const {
  // @@protoc_insertion_point(field_get:Update.mice)
  return mice_.Get(index);
}
 ::Mouse* Update::mutable_mice(int index) {
  // @@protoc_insertion_point(field_mutable:Update.mice)
  return mice_.Mutable(index);
}
 ::Mouse* Update::add_mice() {
  // @@protoc_insertion_point(field_add:Update.mice)
  return mice_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::Mouse >&
Update::mice() const {
  // @@protoc_insertion_point(field_list:Update.mice)
  return mice_;
}
 ::google::protobuf::RepeatedPtrField< ::Mouse >*
Update::mutable_mice() {
  // @@protoc_insertion_point(field_mutable_list:Update.mice)
  return &mice_;
}

// repeated .Position strokes = 6;
int Update::strokes_size() const {
  return strokes_.size();
}
void Update::clear_strokes() {
  strokes_.Clear();
}
 const ::Position& Update::strokes(int index) const {
  // @@protoc_insertion_point(field_get:Update.strokes)
  return strokes_.Get(index);
}
 ::Position* Update::mutable_strokes(int index) {
  // @@protoc_insertion_point(field_mutable:Update.strokes)
  return strokes_.Mutable(index);
}
 ::Position* Update::add_strokes() {
  // @@protoc_insertion_point(field_add:Update.strokes)
  return strokes_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::Position >&
Update::strokes() const {
  // @@protoc_insertion_point(field_list:Update.strokes)
  return strokes_;
}
 ::google::protobuf::RepeatedPtrField< ::Position >*
Update::mutable_strokes() {
  // @@protoc_insertion_point(field_mutable_list:Update.strokes)
  return &strokes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Updates::kModVersionFieldNumber;
const int Updates::kUpdatesFieldNumber;
#endif  // !_MSC_VER

Updates::Updates()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Updates)
}

void Updates::InitAsDefaultInstance() {
}

Updates::Updates(const Updates& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Updates)
}

void Updates::SharedCtor() {
  _cached_size_ = 0;
  mod_version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Updates::~Updates() {
  // @@protoc_insertion_point(destructor:Updates)
  SharedDtor();
}

void Updates::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Updates::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Updates::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Updates_descriptor_;
}

const Updates& Updates::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_update_5fprotocol_2eproto();
  return *default_instance_;
}

Updates* Updates::default_instance_ = NULL;

Updates* Updates::New(::google::protobuf::Arena* arena) const {
  Updates* n = new Updates;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Updates::Clear() {
  mod_version_ = 0;
  updates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Updates::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Updates)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 mod_version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mod_version_)));
          set_has_mod_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_updates;
        break;
      }

      // repeated .Update updates = 2;
      case 2: {
        if (tag == 18) {
         parse_updates:
          DO_(input->IncrementRecursionDepth());
         parse_loop_updates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_updates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_updates;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Updates)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Updates)
  return false;
#undef DO_
}

void Updates::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Updates)
  // required int32 mod_version = 1;
  if (has_mod_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mod_version(), output);
  }

  // repeated .Update updates = 2;
  for (unsigned int i = 0, n = this->updates_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->updates(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Updates)
}

::google::protobuf::uint8* Updates::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Updates)
  // required int32 mod_version = 1;
  if (has_mod_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mod_version(), target);
  }

  // repeated .Update updates = 2;
  for (unsigned int i = 0, n = this->updates_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->updates(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Updates)
  return target;
}

int Updates::ByteSize() const {
  int total_size = 0;

  // required int32 mod_version = 1;
  if (has_mod_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mod_version());
  }
  // repeated .Update updates = 2;
  total_size += 1 * this->updates_size();
  for (int i = 0; i < this->updates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updates(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Updates::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Updates* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Updates>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Updates::MergeFrom(const Updates& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  updates_.MergeFrom(from.updates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mod_version()) {
      set_mod_version(from.mod_version());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Updates::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Updates::CopyFrom(const Updates& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Updates::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->updates())) return false;
  return true;
}

void Updates::Swap(Updates* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Updates::InternalSwap(Updates* other) {
  std::swap(mod_version_, other->mod_version_);
  updates_.UnsafeArenaSwap(&other->updates_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Updates::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Updates_descriptor_;
  metadata.reflection = Updates_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Updates

// required int32 mod_version = 1;
bool Updates::has_mod_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Updates::set_has_mod_version() {
  _has_bits_[0] |= 0x00000001u;
}
void Updates::clear_has_mod_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void Updates::clear_mod_version() {
  mod_version_ = 0;
  clear_has_mod_version();
}
 ::google::protobuf::int32 Updates::mod_version() const {
  // @@protoc_insertion_point(field_get:Updates.mod_version)
  return mod_version_;
}
 void Updates::set_mod_version(::google::protobuf::int32 value) {
  set_has_mod_version();
  mod_version_ = value;
  // @@protoc_insertion_point(field_set:Updates.mod_version)
}

// repeated .Update updates = 2;
int Updates::updates_size() const {
  return updates_.size();
}
void Updates::clear_updates() {
  updates_.Clear();
}
 const ::Update& Updates::updates(int index) const {
  // @@protoc_insertion_point(field_get:Updates.updates)
  return updates_.Get(index);
}
 ::Update* Updates::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:Updates.updates)
  return updates_.Mutable(index);
}
 ::Update* Updates::add_updates() {
  // @@protoc_insertion_point(field_add:Updates.updates)
  return updates_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::Update >&
Updates::updates() const {
  // @@protoc_insertion_point(field_list:Updates.updates)
  return updates_;
}
 ::google::protobuf::RepeatedPtrField< ::Update >*
Updates::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:Updates.updates)
  return &updates_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
