// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_protocol.proto

#ifndef PROTOBUF_update_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_update_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_update_5fprotocol_2eproto();
void protobuf_AssignDesc_update_5fprotocol_2eproto();
void protobuf_ShutdownFile_update_5fprotocol_2eproto();

class Position;
class Rotation;
class Wheel;
class Button;
class Mouse;
class DataDescription;
class LabeledMarker;
class TrackedBody;
class Mocap;
class Update;
class Updates;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Rotation : public ::google::protobuf::Message {
 public:
  Rotation();
  virtual ~Rotation();

  Rotation(const Rotation& from);

  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rotation& default_instance();

  void Swap(Rotation* other);

  // implements Message ----------------------------------------------

  inline Rotation* New() const { return New(NULL); }

  Rotation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rotation& from);
  void MergeFrom(const Rotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:Rotation)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Rotation* default_instance_;
};
// -------------------------------------------------------------------

class Wheel : public ::google::protobuf::Message {
 public:
  Wheel();
  virtual ~Wheel();

  Wheel(const Wheel& from);

  inline Wheel& operator=(const Wheel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wheel& default_instance();

  void Swap(Wheel* other);

  // implements Message ----------------------------------------------

  inline Wheel* New() const { return New(NULL); }

  Wheel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Wheel& from);
  void MergeFrom(const Wheel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Wheel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  const ::std::string& direction() const;
  void set_direction(const ::std::string& value);
  void set_direction(const char* value);
  void set_direction(const char* value, size_t size);
  ::std::string* mutable_direction();
  ::std::string* release_direction();
  void set_allocated_direction(::std::string* direction);

  // required int32 tick = 3;
  bool has_tick() const;
  void clear_tick();
  static const int kTickFieldNumber = 3;
  ::google::protobuf::int32 tick() const;
  void set_tick(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Wheel)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_tick();
  inline void clear_has_tick();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr direction_;
  ::google::protobuf::int32 tick_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Wheel* default_instance_;
};
// -------------------------------------------------------------------

class Button : public ::google::protobuf::Message {
 public:
  Button();
  virtual ~Button();

  Button(const Button& from);

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Button& default_instance();

  void Swap(Button* other);

  // implements Message ----------------------------------------------

  inline Button* New() const { return New(NULL); }

  Button* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Button& from);
  void MergeFrom(const Button& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Button* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // @@protoc_insertion_point(class_scope:Button)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Button* default_instance_;
};
// -------------------------------------------------------------------

class Mouse : public ::google::protobuf::Message {
 public:
  Mouse();
  virtual ~Mouse();

  Mouse(const Mouse& from);

  inline Mouse& operator=(const Mouse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mouse& default_instance();

  void Swap(Mouse* other);

  // implements Message ----------------------------------------------

  inline Mouse* New() const { return New(NULL); }

  Mouse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mouse& from);
  void MergeFrom(const Mouse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mouse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required bool connected = 2;
  bool has_connected() const;
  void clear_connected();
  static const int kConnectedFieldNumber = 2;
  bool connected() const;
  void set_connected(bool value);

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .Button buttons = 4;
  int buttons_size() const;
  void clear_buttons();
  static const int kButtonsFieldNumber = 4;
  const ::Button& buttons(int index) const;
  ::Button* mutable_buttons(int index);
  ::Button* add_buttons();
  const ::google::protobuf::RepeatedPtrField< ::Button >&
      buttons() const;
  ::google::protobuf::RepeatedPtrField< ::Button >*
      mutable_buttons();

  // repeated .Wheel wheels = 5;
  int wheels_size() const;
  void clear_wheels();
  static const int kWheelsFieldNumber = 5;
  const ::Wheel& wheels(int index) const;
  ::Wheel* mutable_wheels(int index);
  ::Wheel* add_wheels();
  const ::google::protobuf::RepeatedPtrField< ::Wheel >&
      wheels() const;
  ::google::protobuf::RepeatedPtrField< ::Wheel >*
      mutable_wheels();

  // @@protoc_insertion_point(class_scope:Mouse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_connected();
  inline void clear_has_connected();
  inline void set_has_name();
  inline void clear_has_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::Button > buttons_;
  ::google::protobuf::RepeatedPtrField< ::Wheel > wheels_;
  bool connected_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Mouse* default_instance_;
};
// -------------------------------------------------------------------

class DataDescription : public ::google::protobuf::Message {
 public:
  DataDescription();
  virtual ~DataDescription();

  DataDescription(const DataDescription& from);

  inline DataDescription& operator=(const DataDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataDescription& default_instance();

  void Swap(DataDescription* other);

  // implements Message ----------------------------------------------

  inline DataDescription* New() const { return New(NULL); }

  DataDescription* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataDescription& from);
  void MergeFrom(const DataDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 dd_id = 2;
  bool has_dd_id() const;
  void clear_dd_id();
  static const int kDdIdFieldNumber = 2;
  ::google::protobuf::int32 dd_id() const;
  void set_dd_id(::google::protobuf::int32 value);

  // required int32 item_id = 3;
  bool has_item_id() const;
  void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  ::google::protobuf::int32 item_id() const;
  void set_item_id(::google::protobuf::int32 value);

  // required sint32 parentId = 4;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 4;
  ::google::protobuf::int32 parentid() const;
  void set_parentid(::google::protobuf::int32 value);

  // required sint32 parentOffsetX = 5;
  bool has_parentoffsetx() const;
  void clear_parentoffsetx();
  static const int kParentOffsetXFieldNumber = 5;
  ::google::protobuf::int32 parentoffsetx() const;
  void set_parentoffsetx(::google::protobuf::int32 value);

  // required sint32 parentOffsetY = 6;
  bool has_parentoffsety() const;
  void clear_parentoffsety();
  static const int kParentOffsetYFieldNumber = 6;
  ::google::protobuf::int32 parentoffsety() const;
  void set_parentoffsety(::google::protobuf::int32 value);

  // required sint32 parentOffsetZ = 7;
  bool has_parentoffsetz() const;
  void clear_parentoffsetz();
  static const int kParentOffsetZFieldNumber = 7;
  ::google::protobuf::int32 parentoffsetz() const;
  void set_parentoffsetz(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DataDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dd_id();
  inline void clear_has_dd_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_parentid();
  inline void clear_has_parentid();
  inline void set_has_parentoffsetx();
  inline void clear_has_parentoffsetx();
  inline void set_has_parentoffsety();
  inline void clear_has_parentoffsety();
  inline void set_has_parentoffsetz();
  inline void clear_has_parentoffsetz();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 dd_id_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 parentid_;
  ::google::protobuf::int32 parentoffsetx_;
  ::google::protobuf::int32 parentoffsety_;
  ::google::protobuf::int32 parentoffsetz_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static DataDescription* default_instance_;
};
// -------------------------------------------------------------------

class LabeledMarker : public ::google::protobuf::Message {
 public:
  LabeledMarker();
  virtual ~LabeledMarker();

  LabeledMarker(const LabeledMarker& from);

  inline LabeledMarker& operator=(const LabeledMarker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LabeledMarker& default_instance();

  void Swap(LabeledMarker* other);

  // implements Message ----------------------------------------------

  inline LabeledMarker* New() const { return New(NULL); }

  LabeledMarker* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabeledMarker& from);
  void MergeFrom(const LabeledMarker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LabeledMarker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required double size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  double size() const;
  void set_size(double value);

  // required .Position position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::Position& position() const;
  ::Position* mutable_position();
  ::Position* release_position();
  void set_allocated_position(::Position* position);

  // @@protoc_insertion_point(class_scope:LabeledMarker)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double size_;
  ::Position* position_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static LabeledMarker* default_instance_;
};
// -------------------------------------------------------------------

class TrackedBody : public ::google::protobuf::Message {
 public:
  TrackedBody();
  virtual ~TrackedBody();

  TrackedBody(const TrackedBody& from);

  inline TrackedBody& operator=(const TrackedBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedBody& default_instance();

  void Swap(TrackedBody* other);

  // implements Message ----------------------------------------------

  inline TrackedBody* New() const { return New(NULL); }

  TrackedBody* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackedBody& from);
  void MergeFrom(const TrackedBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrackedBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // required bool trackingValid = 3;
  bool has_trackingvalid() const;
  void clear_trackingvalid();
  static const int kTrackingValidFieldNumber = 3;
  bool trackingvalid() const;
  void set_trackingvalid(bool value);

  // required .Position position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  const ::Position& position() const;
  ::Position* mutable_position();
  ::Position* release_position();
  void set_allocated_position(::Position* position);

  // required .Rotation rotation = 5;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 5;
  const ::Rotation& rotation() const;
  ::Rotation* mutable_rotation();
  ::Rotation* release_rotation();
  void set_allocated_rotation(::Rotation* rotation);

  // optional float meanError = 6;
  bool has_meanerror() const;
  void clear_meanerror();
  static const int kMeanErrorFieldNumber = 6;
  float meanerror() const;
  void set_meanerror(float value);

  // repeated .LabeledMarker markers = 7;
  int markers_size() const;
  void clear_markers();
  static const int kMarkersFieldNumber = 7;
  const ::LabeledMarker& markers(int index) const;
  ::LabeledMarker* mutable_markers(int index);
  ::LabeledMarker* add_markers();
  const ::google::protobuf::RepeatedPtrField< ::LabeledMarker >&
      markers() const;
  ::google::protobuf::RepeatedPtrField< ::LabeledMarker >*
      mutable_markers();

  // @@protoc_insertion_point(class_scope:TrackedBody)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_trackingvalid();
  inline void clear_has_trackingvalid();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_meanerror();
  inline void clear_has_meanerror();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::int32 id_;
  bool trackingvalid_;
  ::Position* position_;
  ::Rotation* rotation_;
  ::google::protobuf::RepeatedPtrField< ::LabeledMarker > markers_;
  float meanerror_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static TrackedBody* default_instance_;
};
// -------------------------------------------------------------------

class Mocap : public ::google::protobuf::Message {
 public:
  Mocap();
  virtual ~Mocap();

  Mocap(const Mocap& from);

  inline Mocap& operator=(const Mocap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mocap& default_instance();

  void Swap(Mocap* other);

  // implements Message ----------------------------------------------

  inline Mocap* New() const { return New(NULL); }

  Mocap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mocap& from);
  void MergeFrom(const Mocap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mocap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool duringRecording = 1;
  bool has_duringrecording() const;
  void clear_duringrecording();
  static const int kDuringRecordingFieldNumber = 1;
  bool duringrecording() const;
  void set_duringrecording(bool value);

  // required bool trackedModelsChanged = 2;
  bool has_trackedmodelschanged() const;
  void clear_trackedmodelschanged();
  static const int kTrackedModelsChangedFieldNumber = 2;
  bool trackedmodelschanged() const;
  void set_trackedmodelschanged(bool value);

  // optional string timecode = 3;
  bool has_timecode() const;
  void clear_timecode();
  static const int kTimecodeFieldNumber = 3;
  const ::std::string& timecode() const;
  void set_timecode(const ::std::string& value);
  void set_timecode(const char* value);
  void set_timecode(const char* value, size_t size);
  ::std::string* mutable_timecode();
  ::std::string* release_timecode();
  void set_allocated_timecode(::std::string* timecode);

  // repeated .TrackedBody tracked_bodies = 4;
  int tracked_bodies_size() const;
  void clear_tracked_bodies();
  static const int kTrackedBodiesFieldNumber = 4;
  const ::TrackedBody& tracked_bodies(int index) const;
  ::TrackedBody* mutable_tracked_bodies(int index);
  ::TrackedBody* add_tracked_bodies();
  const ::google::protobuf::RepeatedPtrField< ::TrackedBody >&
      tracked_bodies() const;
  ::google::protobuf::RepeatedPtrField< ::TrackedBody >*
      mutable_tracked_bodies();

  // @@protoc_insertion_point(class_scope:Mocap)
 private:
  inline void set_has_duringrecording();
  inline void clear_has_duringrecording();
  inline void set_has_trackedmodelschanged();
  inline void clear_has_trackedmodelschanged();
  inline void set_has_timecode();
  inline void clear_has_timecode();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr timecode_;
  ::google::protobuf::RepeatedPtrField< ::TrackedBody > tracked_bodies_;
  bool duringrecording_;
  bool trackedmodelschanged_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Mocap* default_instance_;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::Message {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  void Swap(Update* other);

  // implements Message ----------------------------------------------

  inline Update* New() const { return New(NULL); }

  Update* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required int32 mod_version = 2;
  bool has_mod_version() const;
  void clear_mod_version();
  static const int kModVersionFieldNumber = 2;
  ::google::protobuf::int32 mod_version() const;
  void set_mod_version(::google::protobuf::int32 value);

  // required int32 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // optional .Mocap mocap = 4;
  bool has_mocap() const;
  void clear_mocap();
  static const int kMocapFieldNumber = 4;
  const ::Mocap& mocap() const;
  ::Mocap* mutable_mocap();
  ::Mocap* release_mocap();
  void set_allocated_mocap(::Mocap* mocap);

  // repeated .Mouse mice = 5;
  int mice_size() const;
  void clear_mice();
  static const int kMiceFieldNumber = 5;
  const ::Mouse& mice(int index) const;
  ::Mouse* mutable_mice(int index);
  ::Mouse* add_mice();
  const ::google::protobuf::RepeatedPtrField< ::Mouse >&
      mice() const;
  ::google::protobuf::RepeatedPtrField< ::Mouse >*
      mutable_mice();

  // repeated .Position strokes = 6;
  int strokes_size() const;
  void clear_strokes();
  static const int kStrokesFieldNumber = 6;
  const ::Position& strokes(int index) const;
  ::Position* mutable_strokes(int index);
  ::Position* add_strokes();
  const ::google::protobuf::RepeatedPtrField< ::Position >&
      strokes() const;
  ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_strokes();

  // @@protoc_insertion_point(class_scope:Update)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mod_version();
  inline void clear_has_mod_version();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_mocap();
  inline void clear_has_mocap();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int32 mod_version_;
  ::google::protobuf::int32 time_;
  ::Mocap* mocap_;
  ::google::protobuf::RepeatedPtrField< ::Mouse > mice_;
  ::google::protobuf::RepeatedPtrField< ::Position > strokes_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Update* default_instance_;
};
// -------------------------------------------------------------------

class Updates : public ::google::protobuf::Message {
 public:
  Updates();
  virtual ~Updates();

  Updates(const Updates& from);

  inline Updates& operator=(const Updates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Updates& default_instance();

  void Swap(Updates* other);

  // implements Message ----------------------------------------------

  inline Updates* New() const { return New(NULL); }

  Updates* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Updates& from);
  void MergeFrom(const Updates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Updates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mod_version = 1;
  bool has_mod_version() const;
  void clear_mod_version();
  static const int kModVersionFieldNumber = 1;
  ::google::protobuf::int32 mod_version() const;
  void set_mod_version(::google::protobuf::int32 value);

  // repeated .Update updates = 2;
  int updates_size() const;
  void clear_updates();
  static const int kUpdatesFieldNumber = 2;
  const ::Update& updates(int index) const;
  ::Update* mutable_updates(int index);
  ::Update* add_updates();
  const ::google::protobuf::RepeatedPtrField< ::Update >&
      updates() const;
  ::google::protobuf::RepeatedPtrField< ::Update >*
      mutable_updates();

  // @@protoc_insertion_point(class_scope:Updates)
 private:
  inline void set_has_mod_version();
  inline void clear_has_mod_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Update > updates_;
  ::google::protobuf::int32 mod_version_;
  friend void  protobuf_AddDesc_update_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_update_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_update_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Updates* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Position::x() const {
  // @@protoc_insertion_point(field_get:Position.x)
  return x_;
}
inline void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Position.x)
}

// required double y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Position::y() const {
  // @@protoc_insertion_point(field_get:Position.y)
  return y_;
}
inline void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Position.y)
}

// required double z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Position::z() const {
  // @@protoc_insertion_point(field_get:Position.z)
  return z_;
}
inline void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Position.z)
}

// -------------------------------------------------------------------

// Rotation

// required double x = 1;
inline bool Rotation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rotation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rotation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rotation::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Rotation::x() const {
  // @@protoc_insertion_point(field_get:Rotation.x)
  return x_;
}
inline void Rotation::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Rotation.x)
}

// required double y = 2;
inline bool Rotation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rotation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rotation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rotation::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Rotation::y() const {
  // @@protoc_insertion_point(field_get:Rotation.y)
  return y_;
}
inline void Rotation::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Rotation.y)
}

// required double z = 3;
inline bool Rotation::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rotation::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rotation::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rotation::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Rotation::z() const {
  // @@protoc_insertion_point(field_get:Rotation.z)
  return z_;
}
inline void Rotation::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Rotation.z)
}

// required double w = 4;
inline bool Rotation::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rotation::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rotation::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rotation::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Rotation::w() const {
  // @@protoc_insertion_point(field_get:Rotation.w)
  return w_;
}
inline void Rotation::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Rotation.w)
}

// -------------------------------------------------------------------

// Wheel

// required string id = 1;
inline bool Wheel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wheel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wheel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wheel::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Wheel::id() const {
  // @@protoc_insertion_point(field_get:Wheel.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wheel::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Wheel.id)
}
inline void Wheel::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Wheel.id)
}
inline void Wheel::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Wheel.id)
}
inline ::std::string* Wheel::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Wheel.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Wheel::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wheel::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Wheel.id)
}

// required string direction = 2;
inline bool Wheel::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wheel::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wheel::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wheel::clear_direction() {
  direction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_direction();
}
inline const ::std::string& Wheel::direction() const {
  // @@protoc_insertion_point(field_get:Wheel.direction)
  return direction_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wheel::set_direction(const ::std::string& value) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Wheel.direction)
}
inline void Wheel::set_direction(const char* value) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Wheel.direction)
}
inline void Wheel::set_direction(const char* value, size_t size) {
  set_has_direction();
  direction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Wheel.direction)
}
inline ::std::string* Wheel::mutable_direction() {
  set_has_direction();
  // @@protoc_insertion_point(field_mutable:Wheel.direction)
  return direction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Wheel::release_direction() {
  clear_has_direction();
  return direction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Wheel::set_allocated_direction(::std::string* direction) {
  if (direction != NULL) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  direction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), direction);
  // @@protoc_insertion_point(field_set_allocated:Wheel.direction)
}

// required int32 tick = 3;
inline bool Wheel::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Wheel::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Wheel::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Wheel::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
inline ::google::protobuf::int32 Wheel::tick() const {
  // @@protoc_insertion_point(field_get:Wheel.tick)
  return tick_;
}
inline void Wheel::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:Wheel.tick)
}

// -------------------------------------------------------------------

// Button

// required string id = 1;
inline bool Button::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Button::id() const {
  // @@protoc_insertion_point(field_get:Button.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Button::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Button.id)
}
inline void Button::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Button.id)
}
inline void Button::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Button.id)
}
inline ::std::string* Button::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Button.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Button::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Button::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Button.id)
}

// required string state = 2;
inline bool Button::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& Button::state() const {
  // @@protoc_insertion_point(field_get:Button.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Button::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Button.state)
}
inline void Button::set_state(const char* value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Button.state)
}
inline void Button::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Button.state)
}
inline ::std::string* Button::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:Button.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Button::release_state() {
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Button::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:Button.state)
}

// -------------------------------------------------------------------

// Mouse

// required string id = 1;
inline bool Mouse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mouse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mouse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mouse::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Mouse::id() const {
  // @@protoc_insertion_point(field_get:Mouse.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mouse::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mouse.id)
}
inline void Mouse::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mouse.id)
}
inline void Mouse::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mouse.id)
}
inline ::std::string* Mouse::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Mouse.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mouse::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mouse::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Mouse.id)
}

// required bool connected = 2;
inline bool Mouse::has_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mouse::set_has_connected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mouse::clear_has_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mouse::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool Mouse::connected() const {
  // @@protoc_insertion_point(field_get:Mouse.connected)
  return connected_;
}
inline void Mouse::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
  // @@protoc_insertion_point(field_set:Mouse.connected)
}

// required string name = 3;
inline bool Mouse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mouse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mouse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mouse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Mouse::name() const {
  // @@protoc_insertion_point(field_get:Mouse.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mouse::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mouse.name)
}
inline void Mouse::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mouse.name)
}
inline void Mouse::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mouse.name)
}
inline ::std::string* Mouse::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mouse.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mouse::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mouse::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mouse.name)
}

// repeated .Button buttons = 4;
inline int Mouse::buttons_size() const {
  return buttons_.size();
}
inline void Mouse::clear_buttons() {
  buttons_.Clear();
}
inline const ::Button& Mouse::buttons(int index) const {
  // @@protoc_insertion_point(field_get:Mouse.buttons)
  return buttons_.Get(index);
}
inline ::Button* Mouse::mutable_buttons(int index) {
  // @@protoc_insertion_point(field_mutable:Mouse.buttons)
  return buttons_.Mutable(index);
}
inline ::Button* Mouse::add_buttons() {
  // @@protoc_insertion_point(field_add:Mouse.buttons)
  return buttons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Button >&
Mouse::buttons() const {
  // @@protoc_insertion_point(field_list:Mouse.buttons)
  return buttons_;
}
inline ::google::protobuf::RepeatedPtrField< ::Button >*
Mouse::mutable_buttons() {
  // @@protoc_insertion_point(field_mutable_list:Mouse.buttons)
  return &buttons_;
}

// repeated .Wheel wheels = 5;
inline int Mouse::wheels_size() const {
  return wheels_.size();
}
inline void Mouse::clear_wheels() {
  wheels_.Clear();
}
inline const ::Wheel& Mouse::wheels(int index) const {
  // @@protoc_insertion_point(field_get:Mouse.wheels)
  return wheels_.Get(index);
}
inline ::Wheel* Mouse::mutable_wheels(int index) {
  // @@protoc_insertion_point(field_mutable:Mouse.wheels)
  return wheels_.Mutable(index);
}
inline ::Wheel* Mouse::add_wheels() {
  // @@protoc_insertion_point(field_add:Mouse.wheels)
  return wheels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Wheel >&
Mouse::wheels() const {
  // @@protoc_insertion_point(field_list:Mouse.wheels)
  return wheels_;
}
inline ::google::protobuf::RepeatedPtrField< ::Wheel >*
Mouse::mutable_wheels() {
  // @@protoc_insertion_point(field_mutable_list:Mouse.wheels)
  return &wheels_;
}

// -------------------------------------------------------------------

// DataDescription

// required string name = 1;
inline bool DataDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataDescription::name() const {
  // @@protoc_insertion_point(field_get:DataDescription.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataDescription::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataDescription.name)
}
inline void DataDescription::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataDescription.name)
}
inline void DataDescription::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataDescription.name)
}
inline ::std::string* DataDescription::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:DataDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataDescription::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DataDescription.name)
}

// required int32 dd_id = 2;
inline bool DataDescription::has_dd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataDescription::set_has_dd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataDescription::clear_has_dd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataDescription::clear_dd_id() {
  dd_id_ = 0;
  clear_has_dd_id();
}
inline ::google::protobuf::int32 DataDescription::dd_id() const {
  // @@protoc_insertion_point(field_get:DataDescription.dd_id)
  return dd_id_;
}
inline void DataDescription::set_dd_id(::google::protobuf::int32 value) {
  set_has_dd_id();
  dd_id_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.dd_id)
}

// required int32 item_id = 3;
inline bool DataDescription::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataDescription::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataDescription::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataDescription::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 DataDescription::item_id() const {
  // @@protoc_insertion_point(field_get:DataDescription.item_id)
  return item_id_;
}
inline void DataDescription::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.item_id)
}

// required sint32 parentId = 4;
inline bool DataDescription::has_parentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataDescription::set_has_parentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataDescription::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataDescription::clear_parentid() {
  parentid_ = 0;
  clear_has_parentid();
}
inline ::google::protobuf::int32 DataDescription::parentid() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentId)
  return parentid_;
}
inline void DataDescription::set_parentid(::google::protobuf::int32 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentId)
}

// required sint32 parentOffsetX = 5;
inline bool DataDescription::has_parentoffsetx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataDescription::set_has_parentoffsetx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataDescription::clear_has_parentoffsetx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataDescription::clear_parentoffsetx() {
  parentoffsetx_ = 0;
  clear_has_parentoffsetx();
}
inline ::google::protobuf::int32 DataDescription::parentoffsetx() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetX)
  return parentoffsetx_;
}
inline void DataDescription::set_parentoffsetx(::google::protobuf::int32 value) {
  set_has_parentoffsetx();
  parentoffsetx_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetX)
}

// required sint32 parentOffsetY = 6;
inline bool DataDescription::has_parentoffsety() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataDescription::set_has_parentoffsety() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataDescription::clear_has_parentoffsety() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataDescription::clear_parentoffsety() {
  parentoffsety_ = 0;
  clear_has_parentoffsety();
}
inline ::google::protobuf::int32 DataDescription::parentoffsety() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetY)
  return parentoffsety_;
}
inline void DataDescription::set_parentoffsety(::google::protobuf::int32 value) {
  set_has_parentoffsety();
  parentoffsety_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetY)
}

// required sint32 parentOffsetZ = 7;
inline bool DataDescription::has_parentoffsetz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataDescription::set_has_parentoffsetz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataDescription::clear_has_parentoffsetz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataDescription::clear_parentoffsetz() {
  parentoffsetz_ = 0;
  clear_has_parentoffsetz();
}
inline ::google::protobuf::int32 DataDescription::parentoffsetz() const {
  // @@protoc_insertion_point(field_get:DataDescription.parentOffsetZ)
  return parentoffsetz_;
}
inline void DataDescription::set_parentoffsetz(::google::protobuf::int32 value) {
  set_has_parentoffsetz();
  parentoffsetz_ = value;
  // @@protoc_insertion_point(field_set:DataDescription.parentOffsetZ)
}

// -------------------------------------------------------------------

// LabeledMarker

// required int32 id = 1;
inline bool LabeledMarker::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LabeledMarker::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LabeledMarker::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LabeledMarker::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LabeledMarker::id() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.id)
  return id_;
}
inline void LabeledMarker::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:LabeledMarker.id)
}

// required double size = 2;
inline bool LabeledMarker::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LabeledMarker::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LabeledMarker::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LabeledMarker::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double LabeledMarker::size() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.size)
  return size_;
}
inline void LabeledMarker::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:LabeledMarker.size)
}

// required .Position position = 3;
inline bool LabeledMarker::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LabeledMarker::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LabeledMarker::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LabeledMarker::clear_position() {
  if (position_ != NULL) position_->::Position::Clear();
  clear_has_position();
}
inline const ::Position& LabeledMarker::position() const {
  // @@protoc_insertion_point(field_get:LabeledMarker.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Position* LabeledMarker::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Position;
  }
  // @@protoc_insertion_point(field_mutable:LabeledMarker.position)
  return position_;
}
inline ::Position* LabeledMarker::release_position() {
  clear_has_position();
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void LabeledMarker::set_allocated_position(::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:LabeledMarker.position)
}

// -------------------------------------------------------------------

// TrackedBody

// required int32 id = 1;
inline bool TrackedBody::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedBody::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedBody::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedBody::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TrackedBody::id() const {
  // @@protoc_insertion_point(field_get:TrackedBody.id)
  return id_;
}
inline void TrackedBody::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.id)
}

// required string label = 2;
inline bool TrackedBody::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackedBody::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackedBody::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackedBody::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& TrackedBody::label() const {
  // @@protoc_insertion_point(field_get:TrackedBody.label)
  return label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedBody::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrackedBody.label)
}
inline void TrackedBody::set_label(const char* value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrackedBody.label)
}
inline void TrackedBody::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrackedBody.label)
}
inline ::std::string* TrackedBody::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrackedBody.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrackedBody::release_label() {
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedBody::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.label)
}

// required bool trackingValid = 3;
inline bool TrackedBody::has_trackingvalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackedBody::set_has_trackingvalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackedBody::clear_has_trackingvalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackedBody::clear_trackingvalid() {
  trackingvalid_ = false;
  clear_has_trackingvalid();
}
inline bool TrackedBody::trackingvalid() const {
  // @@protoc_insertion_point(field_get:TrackedBody.trackingValid)
  return trackingvalid_;
}
inline void TrackedBody::set_trackingvalid(bool value) {
  set_has_trackingvalid();
  trackingvalid_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.trackingValid)
}

// required .Position position = 4;
inline bool TrackedBody::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackedBody::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackedBody::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackedBody::clear_position() {
  if (position_ != NULL) position_->::Position::Clear();
  clear_has_position();
}
inline const ::Position& TrackedBody::position() const {
  // @@protoc_insertion_point(field_get:TrackedBody.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Position* TrackedBody::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::Position;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBody.position)
  return position_;
}
inline ::Position* TrackedBody::release_position() {
  clear_has_position();
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TrackedBody::set_allocated_position(::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.position)
}

// required .Rotation rotation = 5;
inline bool TrackedBody::has_rotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackedBody::set_has_rotation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackedBody::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackedBody::clear_rotation() {
  if (rotation_ != NULL) rotation_->::Rotation::Clear();
  clear_has_rotation();
}
inline const ::Rotation& TrackedBody::rotation() const {
  // @@protoc_insertion_point(field_get:TrackedBody.rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::Rotation* TrackedBody::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Rotation;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBody.rotation)
  return rotation_;
}
inline ::Rotation* TrackedBody::release_rotation() {
  clear_has_rotation();
  ::Rotation* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void TrackedBody::set_allocated_rotation(::Rotation* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBody.rotation)
}

// optional float meanError = 6;
inline bool TrackedBody::has_meanerror() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackedBody::set_has_meanerror() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackedBody::clear_has_meanerror() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackedBody::clear_meanerror() {
  meanerror_ = 0;
  clear_has_meanerror();
}
inline float TrackedBody::meanerror() const {
  // @@protoc_insertion_point(field_get:TrackedBody.meanError)
  return meanerror_;
}
inline void TrackedBody::set_meanerror(float value) {
  set_has_meanerror();
  meanerror_ = value;
  // @@protoc_insertion_point(field_set:TrackedBody.meanError)
}

// repeated .LabeledMarker markers = 7;
inline int TrackedBody::markers_size() const {
  return markers_.size();
}
inline void TrackedBody::clear_markers() {
  markers_.Clear();
}
inline const ::LabeledMarker& TrackedBody::markers(int index) const {
  // @@protoc_insertion_point(field_get:TrackedBody.markers)
  return markers_.Get(index);
}
inline ::LabeledMarker* TrackedBody::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:TrackedBody.markers)
  return markers_.Mutable(index);
}
inline ::LabeledMarker* TrackedBody::add_markers() {
  // @@protoc_insertion_point(field_add:TrackedBody.markers)
  return markers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LabeledMarker >&
TrackedBody::markers() const {
  // @@protoc_insertion_point(field_list:TrackedBody.markers)
  return markers_;
}
inline ::google::protobuf::RepeatedPtrField< ::LabeledMarker >*
TrackedBody::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:TrackedBody.markers)
  return &markers_;
}

// -------------------------------------------------------------------

// Mocap

// required bool duringRecording = 1;
inline bool Mocap::has_duringrecording() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mocap::set_has_duringrecording() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mocap::clear_has_duringrecording() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mocap::clear_duringrecording() {
  duringrecording_ = false;
  clear_has_duringrecording();
}
inline bool Mocap::duringrecording() const {
  // @@protoc_insertion_point(field_get:Mocap.duringRecording)
  return duringrecording_;
}
inline void Mocap::set_duringrecording(bool value) {
  set_has_duringrecording();
  duringrecording_ = value;
  // @@protoc_insertion_point(field_set:Mocap.duringRecording)
}

// required bool trackedModelsChanged = 2;
inline bool Mocap::has_trackedmodelschanged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mocap::set_has_trackedmodelschanged() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mocap::clear_has_trackedmodelschanged() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mocap::clear_trackedmodelschanged() {
  trackedmodelschanged_ = false;
  clear_has_trackedmodelschanged();
}
inline bool Mocap::trackedmodelschanged() const {
  // @@protoc_insertion_point(field_get:Mocap.trackedModelsChanged)
  return trackedmodelschanged_;
}
inline void Mocap::set_trackedmodelschanged(bool value) {
  set_has_trackedmodelschanged();
  trackedmodelschanged_ = value;
  // @@protoc_insertion_point(field_set:Mocap.trackedModelsChanged)
}

// optional string timecode = 3;
inline bool Mocap::has_timecode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mocap::set_has_timecode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mocap::clear_has_timecode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mocap::clear_timecode() {
  timecode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timecode();
}
inline const ::std::string& Mocap::timecode() const {
  // @@protoc_insertion_point(field_get:Mocap.timecode)
  return timecode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mocap::set_timecode(const ::std::string& value) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mocap.timecode)
}
inline void Mocap::set_timecode(const char* value) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mocap.timecode)
}
inline void Mocap::set_timecode(const char* value, size_t size) {
  set_has_timecode();
  timecode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mocap.timecode)
}
inline ::std::string* Mocap::mutable_timecode() {
  set_has_timecode();
  // @@protoc_insertion_point(field_mutable:Mocap.timecode)
  return timecode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mocap::release_timecode() {
  clear_has_timecode();
  return timecode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mocap::set_allocated_timecode(::std::string* timecode) {
  if (timecode != NULL) {
    set_has_timecode();
  } else {
    clear_has_timecode();
  }
  timecode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timecode);
  // @@protoc_insertion_point(field_set_allocated:Mocap.timecode)
}

// repeated .TrackedBody tracked_bodies = 4;
inline int Mocap::tracked_bodies_size() const {
  return tracked_bodies_.size();
}
inline void Mocap::clear_tracked_bodies() {
  tracked_bodies_.Clear();
}
inline const ::TrackedBody& Mocap::tracked_bodies(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.tracked_bodies)
  return tracked_bodies_.Get(index);
}
inline ::TrackedBody* Mocap::mutable_tracked_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.tracked_bodies)
  return tracked_bodies_.Mutable(index);
}
inline ::TrackedBody* Mocap::add_tracked_bodies() {
  // @@protoc_insertion_point(field_add:Mocap.tracked_bodies)
  return tracked_bodies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TrackedBody >&
Mocap::tracked_bodies() const {
  // @@protoc_insertion_point(field_list:Mocap.tracked_bodies)
  return tracked_bodies_;
}
inline ::google::protobuf::RepeatedPtrField< ::TrackedBody >*
Mocap::mutable_tracked_bodies() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.tracked_bodies)
  return &tracked_bodies_;
}

// -------------------------------------------------------------------

// Update

// required string id = 1;
inline bool Update::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Update::id() const {
  // @@protoc_insertion_point(field_get:Update.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Update::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Update.id)
}
inline void Update::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Update.id)
}
inline void Update::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Update.id)
}
inline ::std::string* Update::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:Update.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Update::release_id() {
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Update::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Update.id)
}

// required int32 mod_version = 2;
inline bool Update::has_mod_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_mod_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_mod_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Update::clear_mod_version() {
  mod_version_ = 0;
  clear_has_mod_version();
}
inline ::google::protobuf::int32 Update::mod_version() const {
  // @@protoc_insertion_point(field_get:Update.mod_version)
  return mod_version_;
}
inline void Update::set_mod_version(::google::protobuf::int32 value) {
  set_has_mod_version();
  mod_version_ = value;
  // @@protoc_insertion_point(field_set:Update.mod_version)
}

// required int32 time = 3;
inline bool Update::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Update::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Update::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Update::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 Update::time() const {
  // @@protoc_insertion_point(field_get:Update.time)
  return time_;
}
inline void Update::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Update.time)
}

// optional .Mocap mocap = 4;
inline bool Update::has_mocap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Update::set_has_mocap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Update::clear_has_mocap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Update::clear_mocap() {
  if (mocap_ != NULL) mocap_->::Mocap::Clear();
  clear_has_mocap();
}
inline const ::Mocap& Update::mocap() const {
  // @@protoc_insertion_point(field_get:Update.mocap)
  return mocap_ != NULL ? *mocap_ : *default_instance_->mocap_;
}
inline ::Mocap* Update::mutable_mocap() {
  set_has_mocap();
  if (mocap_ == NULL) {
    mocap_ = new ::Mocap;
  }
  // @@protoc_insertion_point(field_mutable:Update.mocap)
  return mocap_;
}
inline ::Mocap* Update::release_mocap() {
  clear_has_mocap();
  ::Mocap* temp = mocap_;
  mocap_ = NULL;
  return temp;
}
inline void Update::set_allocated_mocap(::Mocap* mocap) {
  delete mocap_;
  mocap_ = mocap;
  if (mocap) {
    set_has_mocap();
  } else {
    clear_has_mocap();
  }
  // @@protoc_insertion_point(field_set_allocated:Update.mocap)
}

// repeated .Mouse mice = 5;
inline int Update::mice_size() const {
  return mice_.size();
}
inline void Update::clear_mice() {
  mice_.Clear();
}
inline const ::Mouse& Update::mice(int index) const {
  // @@protoc_insertion_point(field_get:Update.mice)
  return mice_.Get(index);
}
inline ::Mouse* Update::mutable_mice(int index) {
  // @@protoc_insertion_point(field_mutable:Update.mice)
  return mice_.Mutable(index);
}
inline ::Mouse* Update::add_mice() {
  // @@protoc_insertion_point(field_add:Update.mice)
  return mice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mouse >&
Update::mice() const {
  // @@protoc_insertion_point(field_list:Update.mice)
  return mice_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mouse >*
Update::mutable_mice() {
  // @@protoc_insertion_point(field_mutable_list:Update.mice)
  return &mice_;
}

// repeated .Position strokes = 6;
inline int Update::strokes_size() const {
  return strokes_.size();
}
inline void Update::clear_strokes() {
  strokes_.Clear();
}
inline const ::Position& Update::strokes(int index) const {
  // @@protoc_insertion_point(field_get:Update.strokes)
  return strokes_.Get(index);
}
inline ::Position* Update::mutable_strokes(int index) {
  // @@protoc_insertion_point(field_mutable:Update.strokes)
  return strokes_.Mutable(index);
}
inline ::Position* Update::add_strokes() {
  // @@protoc_insertion_point(field_add:Update.strokes)
  return strokes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
Update::strokes() const {
  // @@protoc_insertion_point(field_list:Update.strokes)
  return strokes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
Update::mutable_strokes() {
  // @@protoc_insertion_point(field_mutable_list:Update.strokes)
  return &strokes_;
}

// -------------------------------------------------------------------

// Updates

// required int32 mod_version = 1;
inline bool Updates::has_mod_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Updates::set_has_mod_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Updates::clear_has_mod_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Updates::clear_mod_version() {
  mod_version_ = 0;
  clear_has_mod_version();
}
inline ::google::protobuf::int32 Updates::mod_version() const {
  // @@protoc_insertion_point(field_get:Updates.mod_version)
  return mod_version_;
}
inline void Updates::set_mod_version(::google::protobuf::int32 value) {
  set_has_mod_version();
  mod_version_ = value;
  // @@protoc_insertion_point(field_set:Updates.mod_version)
}

// repeated .Update updates = 2;
inline int Updates::updates_size() const {
  return updates_.size();
}
inline void Updates::clear_updates() {
  updates_.Clear();
}
inline const ::Update& Updates::updates(int index) const {
  // @@protoc_insertion_point(field_get:Updates.updates)
  return updates_.Get(index);
}
inline ::Update* Updates::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:Updates.updates)
  return updates_.Mutable(index);
}
inline ::Update* Updates::add_updates() {
  // @@protoc_insertion_point(field_add:Updates.updates)
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Update >&
Updates::updates() const {
  // @@protoc_insertion_point(field_list:Updates.updates)
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::Update >*
Updates::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:Updates.updates)
  return &updates_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_update_5fprotocol_2eproto__INCLUDED
